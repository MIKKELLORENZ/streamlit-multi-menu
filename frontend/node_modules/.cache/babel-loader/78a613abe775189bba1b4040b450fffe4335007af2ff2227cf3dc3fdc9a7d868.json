{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n/** @ignore */\nexport class ChunkedIterator {\n  constructor() {\n    let numChunks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let getChunkIterator = arguments.length > 1 ? arguments[1] : undefined;\n    this.numChunks = numChunks;\n    this.getChunkIterator = getChunkIterator;\n    this.chunkIndex = 0;\n    this.chunkIterator = this.getChunkIterator(0);\n  }\n  next() {\n    while (this.chunkIndex < this.numChunks) {\n      const next = this.chunkIterator.next();\n      if (!next.done) {\n        return next;\n      }\n      if (++this.chunkIndex < this.numChunks) {\n        this.chunkIterator = this.getChunkIterator(this.chunkIndex);\n      }\n    }\n    return {\n      done: true,\n      value: null\n    };\n  }\n  [Symbol.iterator]() {\n    return this;\n  }\n}\n/** @ignore */\nexport function computeChunkNullCounts(chunks) {\n  return chunks.reduce((nullCount, chunk) => nullCount + chunk.nullCount, 0);\n}\n/** @ignore */\nexport function computeChunkOffsets(chunks) {\n  return chunks.reduce((offsets, chunk, index) => {\n    offsets[index + 1] = offsets[index] + chunk.length;\n    return offsets;\n  }, new Uint32Array(chunks.length + 1));\n}\n/** @ignore */\nexport function sliceChunks(chunks, offsets, begin, end) {\n  const slices = [];\n  for (let i = -1, n = chunks.length; ++i < n;) {\n    const chunk = chunks[i];\n    const offset = offsets[i];\n    const {\n      length\n    } = chunk;\n    // Stop if the child is to the right of the slice boundary\n    if (offset >= end) {\n      break;\n    }\n    // Exclude children to the left of of the slice boundary\n    if (begin >= offset + length) {\n      continue;\n    }\n    // Include entire child if between both left and right boundaries\n    if (offset >= begin && offset + length <= end) {\n      slices.push(chunk);\n      continue;\n    }\n    // Include the child slice that overlaps one of the slice boundaries\n    const from = Math.max(0, begin - offset);\n    const to = Math.min(end - offset, length);\n    slices.push(chunk.slice(from, to - from));\n  }\n  if (slices.length === 0) {\n    slices.push(chunks[0].slice(0, 0));\n  }\n  return slices;\n}\n/** @ignore */\nexport function binarySearch(chunks, offsets, idx, fn) {\n  let lhs = 0,\n    mid = 0,\n    rhs = offsets.length - 1;\n  do {\n    if (lhs >= rhs - 1) {\n      return idx < offsets[rhs] ? fn(chunks, lhs, idx - offsets[lhs]) : null;\n    }\n    mid = lhs + Math.trunc((rhs - lhs) * .5);\n    idx < offsets[mid] ? rhs = mid : lhs = mid;\n  } while (lhs < rhs);\n}\n/** @ignore */\nexport function isChunkedValid(data, index) {\n  return data.getValid(index);\n}\n/** @ignore */\nexport function wrapChunkedCall1(fn) {\n  function chunkedFn(chunks, i, j) {\n    return fn(chunks[i], j);\n  }\n  return function (index) {\n    const data = this.data;\n    return binarySearch(data, this._offsets, index, chunkedFn);\n  };\n}\n/** @ignore */\nexport function wrapChunkedCall2(fn) {\n  let _2;\n  function chunkedFn(chunks, i, j) {\n    return fn(chunks[i], j, _2);\n  }\n  return function (index, value) {\n    const data = this.data;\n    _2 = value;\n    const result = binarySearch(data, this._offsets, index, chunkedFn);\n    _2 = undefined;\n    return result;\n  };\n}\n/** @ignore */\nexport function wrapChunkedIndexOf(indexOf) {\n  let _1;\n  function chunkedIndexOf(data, chunkIndex, fromIndex) {\n    let begin = fromIndex,\n      index = 0,\n      total = 0;\n    for (let i = chunkIndex - 1, n = data.length; ++i < n;) {\n      const chunk = data[i];\n      if (~(index = indexOf(chunk, _1, begin))) {\n        return total + index;\n      }\n      begin = 0;\n      total += chunk.length;\n    }\n    return -1;\n  }\n  return function (element, offset) {\n    _1 = element;\n    const data = this.data;\n    const result = typeof offset !== 'number' ? chunkedIndexOf(data, 0, 0) : binarySearch(data, this._offsets, offset, chunkedIndexOf);\n    _1 = undefined;\n    return result;\n  };\n}","map":{"version":3,"names":["ChunkedIterator","constructor","numChunks","arguments","length","undefined","getChunkIterator","chunkIndex","chunkIterator","next","done","value","Symbol","iterator","computeChunkNullCounts","chunks","reduce","nullCount","chunk","computeChunkOffsets","offsets","index","Uint32Array","sliceChunks","begin","end","slices","i","n","offset","push","from","Math","max","to","min","slice","binarySearch","idx","fn","lhs","mid","rhs","trunc","isChunkedValid","data","getValid","wrapChunkedCall1","chunkedFn","j","_offsets","wrapChunkedCall2","_2","result","wrapChunkedIndexOf","indexOf","_1","chunkedIndexOf","fromIndex","total","element"],"sources":["C:\\Users\\mvlor\\OneDrive\\Desktop\\custom_component\\multi_menu\\template\\multi_menu\\frontend\\node_modules\\apache-arrow\\src\\util\\chunk.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Data } from '../data.js';\nimport { DataType } from '../type.js';\n\n/** @ignore */\nexport class ChunkedIterator<T extends DataType> implements IterableIterator<T['TValue'] | null> {\n    private chunkIndex = 0;\n    private chunkIterator: IterableIterator<T['TValue'] | null>;\n\n    constructor(\n        private numChunks: number = 0,\n        private getChunkIterator: (chunkIndex: number) => IterableIterator<T['TValue'] | null>\n    ) {\n        this.chunkIterator = this.getChunkIterator(0);\n    }\n\n    next(): IteratorResult<T['TValue'] | null> {\n        while (this.chunkIndex < this.numChunks) {\n            const next = this.chunkIterator.next();\n\n            if (!next.done) {\n                return next;\n            }\n\n            if (++this.chunkIndex < this.numChunks) {\n                this.chunkIterator = this.getChunkIterator(this.chunkIndex);\n            }\n        }\n\n        return { done: true, value: null };\n    }\n\n    [Symbol.iterator]() {\n        return this;\n    }\n}\n\n/** @ignore */\nexport function computeChunkNullCounts<T extends DataType>(chunks: ReadonlyArray<Data<T>>) {\n    return chunks.reduce((nullCount, chunk) => nullCount + chunk.nullCount, 0);\n}\n\n/** @ignore */\nexport function computeChunkOffsets<T extends DataType>(chunks: ReadonlyArray<Data<T>>) {\n    return chunks.reduce((offsets, chunk, index) => {\n        offsets[index + 1] = offsets[index] + chunk.length;\n        return offsets;\n    }, new Uint32Array(chunks.length + 1));\n}\n\n/** @ignore */\nexport function sliceChunks<T extends DataType>(chunks: ReadonlyArray<Data<T>>, offsets: Uint32Array | Array<number>, begin: number, end: number) {\n    const slices: Data<T>[] = [];\n    for (let i = -1, n = chunks.length; ++i < n;) {\n        const chunk = chunks[i];\n        const offset = offsets[i];\n        const { length } = chunk;\n        // Stop if the child is to the right of the slice boundary\n        if (offset >= end) { break; }\n        // Exclude children to the left of of the slice boundary\n        if (begin >= offset + length) { continue; }\n        // Include entire child if between both left and right boundaries\n        if (offset >= begin && (offset + length) <= end) {\n            slices.push(chunk);\n            continue;\n        }\n        // Include the child slice that overlaps one of the slice boundaries\n        const from = Math.max(0, begin - offset);\n        const to = Math.min(end - offset, length);\n        slices.push(chunk.slice(from, to - from));\n    }\n    if (slices.length === 0) {\n        slices.push(chunks[0].slice(0, 0));\n    }\n    return slices;\n}\n\n/** @ignore */\nexport function binarySearch<\n    T extends DataType,\n    F extends (chunks: ReadonlyArray<Data<T>>, _1: number, _2: number) => any\n>(chunks: ReadonlyArray<Data<T>>, offsets: Uint32Array | number[], idx: number, fn: F) {\n    let lhs = 0, mid = 0, rhs = offsets.length - 1;\n    do {\n        if (lhs >= rhs - 1) {\n            return (idx < offsets[rhs]) ? fn(chunks, lhs, idx - offsets[lhs]) : null;\n        }\n        mid = lhs + (Math.trunc((rhs - lhs) * .5));\n        idx < offsets[mid] ? (rhs = mid) : (lhs = mid);\n    } while (lhs < rhs);\n}\n\n/** @ignore */\nexport function isChunkedValid<T extends DataType>(data: Data<T>, index: number): boolean {\n    return data.getValid(index);\n}\n\n/** @ignore */\nexport function wrapChunkedCall1<T extends DataType>(fn: (c: Data<T>, _1: number) => any) {\n    function chunkedFn(chunks: ReadonlyArray<Data<T>>, i: number, j: number) { return fn(chunks[i], j); }\n    return function (this: any, index: number) {\n        const data = this.data as ReadonlyArray<Data<T>>;\n        return binarySearch(data, this._offsets, index, chunkedFn);\n    };\n}\n\n/** @ignore */\nexport function wrapChunkedCall2<T extends DataType>(fn: (c: Data<T>, _1: number, _2: any) => any) {\n    let _2: any;\n    function chunkedFn(chunks: ReadonlyArray<Data<T>>, i: number, j: number) { return fn(chunks[i], j, _2); }\n    return function (this: any, index: number, value: any) {\n        const data = this.data as ReadonlyArray<Data<T>>;\n        _2 = value;\n        const result = binarySearch(data, this._offsets, index, chunkedFn);\n        _2 = undefined;\n        return result;\n    };\n}\n\n/** @ignore */\nexport function wrapChunkedIndexOf<T extends DataType>(indexOf: (c: Data<T>, e: T['TValue'], o?: number) => any) {\n    let _1: any;\n    function chunkedIndexOf(data: ReadonlyArray<Data<T>>, chunkIndex: number, fromIndex: number) {\n        let begin = fromIndex, index = 0, total = 0;\n        for (let i = chunkIndex - 1, n = data.length; ++i < n;) {\n            const chunk = data[i];\n            if (~(index = indexOf(chunk, _1, begin))) {\n                return total + index;\n            }\n            begin = 0;\n            total += chunk.length;\n        }\n        return -1;\n    }\n    return function (this: any, element: T['TValue'], offset?: number) {\n        _1 = element;\n        const data = this.data as ReadonlyArray<Data<T>>;\n        const result = typeof offset !== 'number'\n            ? chunkedIndexOf(data, 0, 0)\n            : binarySearch(data, this._offsets, offset, chunkedIndexOf);\n        _1 = undefined;\n        return result;\n    };\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA,OAAM,MAAOA,eAAe;EAIxBC,YAAA,EAE0F;IAAA,IAD9EC,SAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAoB,CAAC;IAAA,IACrBG,gBAA8E,GAAAH,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;IAD9E,KAAAH,SAAS,GAATA,SAAS;IACT,KAAAI,gBAAgB,GAAhBA,gBAAgB;IALpB,KAAAC,UAAU,GAAG,CAAC;IAOlB,IAAI,CAACC,aAAa,GAAG,IAAI,CAACF,gBAAgB,CAAC,CAAC,CAAC;EACjD;EAEAG,IAAIA,CAAA;IACA,OAAO,IAAI,CAACF,UAAU,GAAG,IAAI,CAACL,SAAS,EAAE;MACrC,MAAMO,IAAI,GAAG,IAAI,CAACD,aAAa,CAACC,IAAI,EAAE;MAEtC,IAAI,CAACA,IAAI,CAACC,IAAI,EAAE;QACZ,OAAOD,IAAI;;MAGf,IAAI,EAAE,IAAI,CAACF,UAAU,GAAG,IAAI,CAACL,SAAS,EAAE;QACpC,IAAI,CAACM,aAAa,GAAG,IAAI,CAACF,gBAAgB,CAAC,IAAI,CAACC,UAAU,CAAC;;;IAInE,OAAO;MAAEG,IAAI,EAAE,IAAI;MAAEC,KAAK,EAAE;IAAI,CAAE;EACtC;EAEA,CAACC,MAAM,CAACC,QAAQ,IAAC;IACb,OAAO,IAAI;EACf;;AAGJ;AACA,OAAM,SAAUC,sBAAsBA,CAAqBC,MAA8B;EACrF,OAAOA,MAAM,CAACC,MAAM,CAAC,CAACC,SAAS,EAAEC,KAAK,KAAKD,SAAS,GAAGC,KAAK,CAACD,SAAS,EAAE,CAAC,CAAC;AAC9E;AAEA;AACA,OAAM,SAAUE,mBAAmBA,CAAqBJ,MAA8B;EAClF,OAAOA,MAAM,CAACC,MAAM,CAAC,CAACI,OAAO,EAAEF,KAAK,EAAEG,KAAK,KAAI;IAC3CD,OAAO,CAACC,KAAK,GAAG,CAAC,CAAC,GAAGD,OAAO,CAACC,KAAK,CAAC,GAAGH,KAAK,CAACd,MAAM;IAClD,OAAOgB,OAAO;EAClB,CAAC,EAAE,IAAIE,WAAW,CAACP,MAAM,CAACX,MAAM,GAAG,CAAC,CAAC,CAAC;AAC1C;AAEA;AACA,OAAM,SAAUmB,WAAWA,CAAqBR,MAA8B,EAAEK,OAAoC,EAAEI,KAAa,EAAEC,GAAW;EAC5I,MAAMC,MAAM,GAAc,EAAE;EAC5B,KAAK,IAAIC,CAAC,GAAG,CAAC,CAAC,EAAEC,CAAC,GAAGb,MAAM,CAACX,MAAM,EAAE,EAAEuB,CAAC,GAAGC,CAAC,GAAG;IAC1C,MAAMV,KAAK,GAAGH,MAAM,CAACY,CAAC,CAAC;IACvB,MAAME,MAAM,GAAGT,OAAO,CAACO,CAAC,CAAC;IACzB,MAAM;MAAEvB;IAAM,CAAE,GAAGc,KAAK;IACxB;IACA,IAAIW,MAAM,IAAIJ,GAAG,EAAE;MAAE;;IACrB;IACA,IAAID,KAAK,IAAIK,MAAM,GAAGzB,MAAM,EAAE;MAAE;;IAChC;IACA,IAAIyB,MAAM,IAAIL,KAAK,IAAKK,MAAM,GAAGzB,MAAM,IAAKqB,GAAG,EAAE;MAC7CC,MAAM,CAACI,IAAI,CAACZ,KAAK,CAAC;MAClB;;IAEJ;IACA,MAAMa,IAAI,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC,EAAET,KAAK,GAAGK,MAAM,CAAC;IACxC,MAAMK,EAAE,GAAGF,IAAI,CAACG,GAAG,CAACV,GAAG,GAAGI,MAAM,EAAEzB,MAAM,CAAC;IACzCsB,MAAM,CAACI,IAAI,CAACZ,KAAK,CAACkB,KAAK,CAACL,IAAI,EAAEG,EAAE,GAAGH,IAAI,CAAC,CAAC;;EAE7C,IAAIL,MAAM,CAACtB,MAAM,KAAK,CAAC,EAAE;IACrBsB,MAAM,CAACI,IAAI,CAACf,MAAM,CAAC,CAAC,CAAC,CAACqB,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;;EAEtC,OAAOV,MAAM;AACjB;AAEA;AACA,OAAM,SAAUW,YAAYA,CAG1BtB,MAA8B,EAAEK,OAA+B,EAAEkB,GAAW,EAAEC,EAAK;EACjF,IAAIC,GAAG,GAAG,CAAC;IAAEC,GAAG,GAAG,CAAC;IAAEC,GAAG,GAAGtB,OAAO,CAAChB,MAAM,GAAG,CAAC;EAC9C,GAAG;IACC,IAAIoC,GAAG,IAAIE,GAAG,GAAG,CAAC,EAAE;MAChB,OAAQJ,GAAG,GAAGlB,OAAO,CAACsB,GAAG,CAAC,GAAIH,EAAE,CAACxB,MAAM,EAAEyB,GAAG,EAAEF,GAAG,GAAGlB,OAAO,CAACoB,GAAG,CAAC,CAAC,GAAG,IAAI;;IAE5EC,GAAG,GAAGD,GAAG,GAAIR,IAAI,CAACW,KAAK,CAAC,CAACD,GAAG,GAAGF,GAAG,IAAI,EAAE,CAAE;IAC1CF,GAAG,GAAGlB,OAAO,CAACqB,GAAG,CAAC,GAAIC,GAAG,GAAGD,GAAG,GAAKD,GAAG,GAAGC,GAAI;GACjD,QAAQD,GAAG,GAAGE,GAAG;AACtB;AAEA;AACA,OAAM,SAAUE,cAAcA,CAAqBC,IAAa,EAAExB,KAAa;EAC3E,OAAOwB,IAAI,CAACC,QAAQ,CAACzB,KAAK,CAAC;AAC/B;AAEA;AACA,OAAM,SAAU0B,gBAAgBA,CAAqBR,EAAmC;EACpF,SAASS,SAASA,CAACjC,MAA8B,EAAEY,CAAS,EAAEsB,CAAS;IAAI,OAAOV,EAAE,CAACxB,MAAM,CAACY,CAAC,CAAC,EAAEsB,CAAC,CAAC;EAAE;EACpG,OAAO,UAAqB5B,KAAa;IACrC,MAAMwB,IAAI,GAAG,IAAI,CAACA,IAA8B;IAChD,OAAOR,YAAY,CAACQ,IAAI,EAAE,IAAI,CAACK,QAAQ,EAAE7B,KAAK,EAAE2B,SAAS,CAAC;EAC9D,CAAC;AACL;AAEA;AACA,OAAM,SAAUG,gBAAgBA,CAAqBZ,EAA4C;EAC7F,IAAIa,EAAO;EACX,SAASJ,SAASA,CAACjC,MAA8B,EAAEY,CAAS,EAAEsB,CAAS;IAAI,OAAOV,EAAE,CAACxB,MAAM,CAACY,CAAC,CAAC,EAAEsB,CAAC,EAAEG,EAAE,CAAC;EAAE;EACxG,OAAO,UAAqB/B,KAAa,EAAEV,KAAU;IACjD,MAAMkC,IAAI,GAAG,IAAI,CAACA,IAA8B;IAChDO,EAAE,GAAGzC,KAAK;IACV,MAAM0C,MAAM,GAAGhB,YAAY,CAACQ,IAAI,EAAE,IAAI,CAACK,QAAQ,EAAE7B,KAAK,EAAE2B,SAAS,CAAC;IAClEI,EAAE,GAAG/C,SAAS;IACd,OAAOgD,MAAM;EACjB,CAAC;AACL;AAEA;AACA,OAAM,SAAUC,kBAAkBA,CAAqBC,OAAwD;EAC3G,IAAIC,EAAO;EACX,SAASC,cAAcA,CAACZ,IAA4B,EAAEtC,UAAkB,EAAEmD,SAAiB;IACvF,IAAIlC,KAAK,GAAGkC,SAAS;MAAErC,KAAK,GAAG,CAAC;MAAEsC,KAAK,GAAG,CAAC;IAC3C,KAAK,IAAIhC,CAAC,GAAGpB,UAAU,GAAG,CAAC,EAAEqB,CAAC,GAAGiB,IAAI,CAACzC,MAAM,EAAE,EAAEuB,CAAC,GAAGC,CAAC,GAAG;MACpD,MAAMV,KAAK,GAAG2B,IAAI,CAAClB,CAAC,CAAC;MACrB,IAAI,EAAEN,KAAK,GAAGkC,OAAO,CAACrC,KAAK,EAAEsC,EAAE,EAAEhC,KAAK,CAAC,CAAC,EAAE;QACtC,OAAOmC,KAAK,GAAGtC,KAAK;;MAExBG,KAAK,GAAG,CAAC;MACTmC,KAAK,IAAIzC,KAAK,CAACd,MAAM;;IAEzB,OAAO,CAAC,CAAC;EACb;EACA,OAAO,UAAqBwD,OAAoB,EAAE/B,MAAe;IAC7D2B,EAAE,GAAGI,OAAO;IACZ,MAAMf,IAAI,GAAG,IAAI,CAACA,IAA8B;IAChD,MAAMQ,MAAM,GAAG,OAAOxB,MAAM,KAAK,QAAQ,GACnC4B,cAAc,CAACZ,IAAI,EAAE,CAAC,EAAE,CAAC,CAAC,GAC1BR,YAAY,CAACQ,IAAI,EAAE,IAAI,CAACK,QAAQ,EAAErB,MAAM,EAAE4B,cAAc,CAAC;IAC/DD,EAAE,GAAGnD,SAAS;IACd,OAAOgD,MAAM;EACjB,CAAC;AACL","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}