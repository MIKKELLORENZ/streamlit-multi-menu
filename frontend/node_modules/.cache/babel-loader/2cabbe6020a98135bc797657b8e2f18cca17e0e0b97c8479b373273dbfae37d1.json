{"ast":null,"code":"// automatically generated by the FlatBuffers compiler, do not modify\nimport * as flatbuffers from 'flatbuffers';\nimport { Buffer } from './buffer.mjs';\nimport { Int } from './int.mjs';\n/**\n * ----------------------------------------------------------------------\n * EXPERIMENTAL: Data structures for sparse tensors\n * Coordinate (COO) format of sparse tensor index.\n *\n * COO's index list are represented as a NxM matrix,\n * where N is the number of non-zero values,\n * and M is the number of dimensions of a sparse tensor.\n *\n * indicesBuffer stores the location and size of the data of this indices\n * matrix.  The value type and the stride of the indices matrix is\n * specified in indicesType and indicesStrides fields.\n *\n * For example, let X be a 2x3x4x5 tensor, and it has the following\n * 6 non-zero values:\n * ```text\n *   X[0, 1, 2, 0] := 1\n *   X[1, 1, 2, 3] := 2\n *   X[0, 2, 1, 0] := 3\n *   X[0, 1, 3, 0] := 4\n *   X[0, 1, 2, 1] := 5\n *   X[1, 2, 0, 4] := 6\n * ```\n * In COO format, the index matrix of X is the following 4x6 matrix:\n * ```text\n *   [[0, 0, 0, 0, 1, 1],\n *    [1, 1, 1, 2, 1, 2],\n *    [2, 2, 3, 1, 2, 0],\n *    [0, 1, 0, 0, 3, 4]]\n * ```\n * When isCanonical is true, the indices is sorted in lexicographical order\n * (row-major order), and it does not have duplicated entries.  Otherwise,\n * the indices may not be sorted, or may have duplicated entries.\n */\nexport class SparseTensorIndexCOO {\n  constructor() {\n    this.bb = null;\n    this.bb_pos = 0;\n  }\n  __init(i, bb) {\n    this.bb_pos = i;\n    this.bb = bb;\n    return this;\n  }\n  static getRootAsSparseTensorIndexCOO(bb, obj) {\n    return (obj || new SparseTensorIndexCOO()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n  }\n  static getSizePrefixedRootAsSparseTensorIndexCOO(bb, obj) {\n    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n    return (obj || new SparseTensorIndexCOO()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n  }\n  /**\n   * The type of values in indicesBuffer\n   */\n  indicesType(obj) {\n    const offset = this.bb.__offset(this.bb_pos, 4);\n    return offset ? (obj || new Int()).__init(this.bb.__indirect(this.bb_pos + offset), this.bb) : null;\n  }\n  /**\n   * Non-negative byte offsets to advance one value cell along each dimension\n   * If omitted, default to row-major order (C-like).\n   */\n  indicesStrides(index) {\n    const offset = this.bb.__offset(this.bb_pos, 6);\n    return offset ? this.bb.readInt64(this.bb.__vector(this.bb_pos + offset) + index * 8) : this.bb.createLong(0, 0);\n  }\n  indicesStridesLength() {\n    const offset = this.bb.__offset(this.bb_pos, 6);\n    return offset ? this.bb.__vector_len(this.bb_pos + offset) : 0;\n  }\n  /**\n   * The location and size of the indices matrix's data\n   */\n  indicesBuffer(obj) {\n    const offset = this.bb.__offset(this.bb_pos, 8);\n    return offset ? (obj || new Buffer()).__init(this.bb_pos + offset, this.bb) : null;\n  }\n  /**\n   * This flag is true if and only if the indices matrix is sorted in\n   * row-major order, and does not have duplicated entries.\n   * This sort order is the same as of Tensorflow's SparseTensor,\n   * but it is inverse order of SciPy's canonical coo_matrix\n   * (SciPy employs column-major order for its coo_matrix).\n   */\n  isCanonical() {\n    const offset = this.bb.__offset(this.bb_pos, 10);\n    return offset ? !!this.bb.readInt8(this.bb_pos + offset) : false;\n  }\n  static startSparseTensorIndexCOO(builder) {\n    builder.startObject(4);\n  }\n  static addIndicesType(builder, indicesTypeOffset) {\n    builder.addFieldOffset(0, indicesTypeOffset, 0);\n  }\n  static addIndicesStrides(builder, indicesStridesOffset) {\n    builder.addFieldOffset(1, indicesStridesOffset, 0);\n  }\n  static createIndicesStridesVector(builder, data) {\n    builder.startVector(8, data.length, 8);\n    for (let i = data.length - 1; i >= 0; i--) {\n      builder.addInt64(data[i]);\n    }\n    return builder.endVector();\n  }\n  static startIndicesStridesVector(builder, numElems) {\n    builder.startVector(8, numElems, 8);\n  }\n  static addIndicesBuffer(builder, indicesBufferOffset) {\n    builder.addFieldStruct(2, indicesBufferOffset, 0);\n  }\n  static addIsCanonical(builder, isCanonical) {\n    builder.addFieldInt8(3, +isCanonical, +false);\n  }\n  static endSparseTensorIndexCOO(builder) {\n    const offset = builder.endObject();\n    builder.requiredField(offset, 4); // indicesType\n    builder.requiredField(offset, 8); // indicesBuffer\n    return offset;\n  }\n}","map":{"version":3,"names":["flatbuffers","Buffer","Int","SparseTensorIndexCOO","constructor","bb","bb_pos","__init","i","getRootAsSparseTensorIndexCOO","obj","readInt32","position","getSizePrefixedRootAsSparseTensorIndexCOO","setPosition","SIZE_PREFIX_LENGTH","indicesType","offset","__offset","__indirect","indicesStrides","index","readInt64","__vector","createLong","indicesStridesLength","__vector_len","indicesBuffer","isCanonical","readInt8","startSparseTensorIndexCOO","builder","startObject","addIndicesType","indicesTypeOffset","addFieldOffset","addIndicesStrides","indicesStridesOffset","createIndicesStridesVector","data","startVector","length","addInt64","endVector","startIndicesStridesVector","numElems","addIndicesBuffer","indicesBufferOffset","addFieldStruct","addIsCanonical","addFieldInt8","endSparseTensorIndexCOO","endObject","requiredField"],"sources":["C:\\Users\\mvlor\\OneDrive\\Desktop\\custom_component\\multi_menu\\template\\multi_menu\\frontend\\node_modules\\apache-arrow\\src\\fb\\sparse-tensor-index-c-o-o.ts"],"sourcesContent":["// automatically generated by the FlatBuffers compiler, do not modify\n\nimport * as flatbuffers from 'flatbuffers';\n\nimport { Buffer } from './buffer.js';\nimport { Int } from './int.js';\n\n\n/**\n * ----------------------------------------------------------------------\n * EXPERIMENTAL: Data structures for sparse tensors\n * Coordinate (COO) format of sparse tensor index.\n *\n * COO's index list are represented as a NxM matrix,\n * where N is the number of non-zero values,\n * and M is the number of dimensions of a sparse tensor.\n *\n * indicesBuffer stores the location and size of the data of this indices\n * matrix.  The value type and the stride of the indices matrix is\n * specified in indicesType and indicesStrides fields.\n *\n * For example, let X be a 2x3x4x5 tensor, and it has the following\n * 6 non-zero values:\n * ```text\n *   X[0, 1, 2, 0] := 1\n *   X[1, 1, 2, 3] := 2\n *   X[0, 2, 1, 0] := 3\n *   X[0, 1, 3, 0] := 4\n *   X[0, 1, 2, 1] := 5\n *   X[1, 2, 0, 4] := 6\n * ```\n * In COO format, the index matrix of X is the following 4x6 matrix:\n * ```text\n *   [[0, 0, 0, 0, 1, 1],\n *    [1, 1, 1, 2, 1, 2],\n *    [2, 2, 3, 1, 2, 0],\n *    [0, 1, 0, 0, 3, 4]]\n * ```\n * When isCanonical is true, the indices is sorted in lexicographical order\n * (row-major order), and it does not have duplicated entries.  Otherwise,\n * the indices may not be sorted, or may have duplicated entries.\n */\nexport class SparseTensorIndexCOO {\n  bb: flatbuffers.ByteBuffer|null = null;\n  bb_pos = 0;\n__init(i:number, bb:flatbuffers.ByteBuffer):SparseTensorIndexCOO {\n  this.bb_pos = i;\n  this.bb = bb;\n  return this;\n}\n\nstatic getRootAsSparseTensorIndexCOO(bb:flatbuffers.ByteBuffer, obj?:SparseTensorIndexCOO):SparseTensorIndexCOO {\n  return (obj || new SparseTensorIndexCOO()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n}\n\nstatic getSizePrefixedRootAsSparseTensorIndexCOO(bb:flatbuffers.ByteBuffer, obj?:SparseTensorIndexCOO):SparseTensorIndexCOO {\n  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);\n  return (obj || new SparseTensorIndexCOO()).__init(bb.readInt32(bb.position()) + bb.position(), bb);\n}\n\n/**\n * The type of values in indicesBuffer\n */\nindicesType(obj?:Int):Int|null {\n  const offset = this.bb!.__offset(this.bb_pos, 4);\n  return offset ? (obj || new Int()).__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) : null;\n}\n\n/**\n * Non-negative byte offsets to advance one value cell along each dimension\n * If omitted, default to row-major order (C-like).\n */\nindicesStrides(index: number):flatbuffers.Long|null {\n  const offset = this.bb!.__offset(this.bb_pos, 6);\n  return offset ? this.bb!.readInt64(this.bb!.__vector(this.bb_pos + offset) + index * 8) : this.bb!.createLong(0, 0);\n}\n\nindicesStridesLength():number {\n  const offset = this.bb!.__offset(this.bb_pos, 6);\n  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;\n}\n\n/**\n * The location and size of the indices matrix's data\n */\nindicesBuffer(obj?:Buffer):Buffer|null {\n  const offset = this.bb!.__offset(this.bb_pos, 8);\n  return offset ? (obj || new Buffer()).__init(this.bb_pos + offset, this.bb!) : null;\n}\n\n/**\n * This flag is true if and only if the indices matrix is sorted in\n * row-major order, and does not have duplicated entries.\n * This sort order is the same as of Tensorflow's SparseTensor,\n * but it is inverse order of SciPy's canonical coo_matrix\n * (SciPy employs column-major order for its coo_matrix).\n */\nisCanonical():boolean {\n  const offset = this.bb!.__offset(this.bb_pos, 10);\n  return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;\n}\n\nstatic startSparseTensorIndexCOO(builder:flatbuffers.Builder) {\n  builder.startObject(4);\n}\n\nstatic addIndicesType(builder:flatbuffers.Builder, indicesTypeOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(0, indicesTypeOffset, 0);\n}\n\nstatic addIndicesStrides(builder:flatbuffers.Builder, indicesStridesOffset:flatbuffers.Offset) {\n  builder.addFieldOffset(1, indicesStridesOffset, 0);\n}\n\nstatic createIndicesStridesVector(builder:flatbuffers.Builder, data:flatbuffers.Long[]):flatbuffers.Offset {\n  builder.startVector(8, data.length, 8);\n  for (let i = data.length - 1; i >= 0; i--) {\n    builder.addInt64(data[i]!);\n  }\n  return builder.endVector();\n}\n\nstatic startIndicesStridesVector(builder:flatbuffers.Builder, numElems:number) {\n  builder.startVector(8, numElems, 8);\n}\n\nstatic addIndicesBuffer(builder:flatbuffers.Builder, indicesBufferOffset:flatbuffers.Offset) {\n  builder.addFieldStruct(2, indicesBufferOffset, 0);\n}\n\nstatic addIsCanonical(builder:flatbuffers.Builder, isCanonical:boolean) {\n  builder.addFieldInt8(3, +isCanonical, +false);\n}\n\nstatic endSparseTensorIndexCOO(builder:flatbuffers.Builder):flatbuffers.Offset {\n  const offset = builder.endObject();\n  builder.requiredField(offset, 4) // indicesType\n  builder.requiredField(offset, 8) // indicesBuffer\n  return offset;\n}\n\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}