{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nvar _a;\nimport { Data, makeData } from './data.mjs';\nimport { Table } from './table.mjs';\nimport { Vector } from './vector.mjs';\nimport { Schema, Field } from './schema.mjs';\nimport { DataType, Struct, Null } from './type.mjs';\nimport { instance as getVisitor } from './visitor/get.mjs';\nimport { instance as setVisitor } from './visitor/set.mjs';\nimport { instance as indexOfVisitor } from './visitor/indexof.mjs';\nimport { instance as iteratorVisitor } from './visitor/iterator.mjs';\nimport { instance as byteLengthVisitor } from './visitor/bytelength.mjs';\n/** @ignore */\nexport class RecordBatch {\n  constructor() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    switch (args.length) {\n      case 2:\n        {\n          [this.schema] = args;\n          if (!(this.schema instanceof Schema)) {\n            throw new TypeError('RecordBatch constructor expects a [Schema, Data] pair.');\n          }\n          [, this.data = makeData({\n            nullCount: 0,\n            type: new Struct(this.schema.fields),\n            children: this.schema.fields.map(f => makeData({\n              type: f.type,\n              nullCount: 0\n            }))\n          })] = args;\n          if (!(this.data instanceof Data)) {\n            throw new TypeError('RecordBatch constructor expects a [Schema, Data] pair.');\n          }\n          [this.schema, this.data] = ensureSameLengthData(this.schema, this.data.children);\n          break;\n        }\n      case 1:\n        {\n          const [obj] = args;\n          const {\n            fields,\n            children,\n            length\n          } = Object.keys(obj).reduce((memo, name, i) => {\n            memo.children[i] = obj[name];\n            memo.length = Math.max(memo.length, obj[name].length);\n            memo.fields[i] = Field.new({\n              name,\n              type: obj[name].type,\n              nullable: true\n            });\n            return memo;\n          }, {\n            length: 0,\n            fields: new Array(),\n            children: new Array()\n          });\n          const schema = new Schema(fields);\n          const data = makeData({\n            type: new Struct(fields),\n            length,\n            children,\n            nullCount: 0\n          });\n          [this.schema, this.data] = ensureSameLengthData(schema, data.children, length);\n          break;\n        }\n      default:\n        throw new TypeError('RecordBatch constructor expects an Object mapping names to child Data, or a [Schema, Data] pair.');\n    }\n  }\n  get dictionaries() {\n    return this._dictionaries || (this._dictionaries = collectDictionaries(this.schema.fields, this.data.children));\n  }\n  /**\n   * The number of columns in this RecordBatch.\n   */\n  get numCols() {\n    return this.schema.fields.length;\n  }\n  /**\n   * The number of rows in this RecordBatch.\n   */\n  get numRows() {\n    return this.data.length;\n  }\n  /**\n   * The number of null rows in this RecordBatch.\n   */\n  get nullCount() {\n    return this.data.nullCount;\n  }\n  /**\n   * Check whether an element is null.\n   * @param index The index at which to read the validity bitmap.\n   */\n  isValid(index) {\n    return this.data.getValid(index);\n  }\n  /**\n   * Get a row by position.\n   * @param index The index of the element to read.\n   */\n  get(index) {\n    return getVisitor.visit(this.data, index);\n  }\n  /**\n   * Set a row by position.\n   * @param index The index of the element to write.\n   * @param value The value to set.\n   */\n  set(index, value) {\n    return setVisitor.visit(this.data, index, value);\n  }\n  /**\n   * Retrieve the index of the first occurrence of a row in an RecordBatch.\n   * @param element The row to locate in the RecordBatch.\n   * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.\n   */\n  indexOf(element, offset) {\n    return indexOfVisitor.visit(this.data, element, offset);\n  }\n  /**\n   * Get the size (in bytes) of a row by index.\n   * @param index The row index for which to compute the byteLength.\n   */\n  getByteLength(index) {\n    return byteLengthVisitor.visit(this.data, index);\n  }\n  /**\n   * Iterator for rows in this RecordBatch.\n   */\n  [Symbol.iterator]() {\n    return iteratorVisitor.visit(new Vector([this.data]));\n  }\n  /**\n   * Return a JavaScript Array of the RecordBatch rows.\n   * @returns An Array of RecordBatch rows.\n   */\n  toArray() {\n    return [...this];\n  }\n  /**\n   * Combines two or more RecordBatch of the same schema.\n   * @param others Additional RecordBatch to add to the end of this RecordBatch.\n   */\n  concat() {\n    for (var _len2 = arguments.length, others = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      others[_key2] = arguments[_key2];\n    }\n    return new Table(this.schema, [this, ...others]);\n  }\n  /**\n   * Return a zero-copy sub-section of this RecordBatch.\n   * @param start The beginning of the specified portion of the RecordBatch.\n   * @param end The end of the specified portion of the RecordBatch. This is exclusive of the element at the index 'end'.\n   */\n  slice(begin, end) {\n    const [slice] = new Vector([this.data]).slice(begin, end).data;\n    return new RecordBatch(this.schema, slice);\n  }\n  /**\n   * Returns a child Vector by name, or null if this Vector has no child with the given name.\n   * @param name The name of the child to retrieve.\n   */\n  getChild(name) {\n    var _b;\n    return this.getChildAt((_b = this.schema.fields) === null || _b === void 0 ? void 0 : _b.findIndex(f => f.name === name));\n  }\n  /**\n   * Returns a child Vector by index, or null if this Vector has no child at the supplied index.\n   * @param index The index of the child to retrieve.\n   */\n  getChildAt(index) {\n    if (index > -1 && index < this.schema.fields.length) {\n      return new Vector([this.data.children[index]]);\n    }\n    return null;\n  }\n  /**\n   * Sets a child Vector by name.\n   * @param name The name of the child to overwrite.\n   * @returns A new RecordBatch with the new child for the specified name.\n   */\n  setChild(name, child) {\n    var _b;\n    return this.setChildAt((_b = this.schema.fields) === null || _b === void 0 ? void 0 : _b.findIndex(f => f.name === name), child);\n  }\n  setChildAt(index, child) {\n    let schema = this.schema;\n    let data = this.data;\n    if (index > -1 && index < this.numCols) {\n      if (!child) {\n        child = new Vector([makeData({\n          type: new Null(),\n          length: this.numRows\n        })]);\n      }\n      const fields = schema.fields.slice();\n      const children = data.children.slice();\n      const field = fields[index].clone({\n        type: child.type\n      });\n      [fields[index], children[index]] = [field, child.data[0]];\n      schema = new Schema(fields, new Map(this.schema.metadata));\n      data = makeData({\n        type: new Struct(fields),\n        children\n      });\n    }\n    return new RecordBatch(schema, data);\n  }\n  /**\n   * Construct a new RecordBatch containing only specified columns.\n   *\n   * @param columnNames Names of columns to keep.\n   * @returns A new RecordBatch of columns matching the specified names.\n   */\n  select(columnNames) {\n    const schema = this.schema.select(columnNames);\n    const type = new Struct(schema.fields);\n    const children = [];\n    for (const name of columnNames) {\n      const index = this.schema.fields.findIndex(f => f.name === name);\n      if (~index) {\n        children[index] = this.data.children[index];\n      }\n    }\n    return new RecordBatch(schema, makeData({\n      type,\n      length: this.numRows,\n      children\n    }));\n  }\n  /**\n   * Construct a new RecordBatch containing only columns at the specified indices.\n   *\n   * @param columnIndices Indices of columns to keep.\n   * @returns A new RecordBatch of columns matching at the specified indices.\n   */\n  selectAt(columnIndices) {\n    const schema = this.schema.selectAt(columnIndices);\n    const children = columnIndices.map(i => this.data.children[i]).filter(Boolean);\n    const subset = makeData({\n      type: new Struct(schema.fields),\n      length: this.numRows,\n      children\n    });\n    return new RecordBatch(schema, subset);\n  }\n}\n_a = Symbol.toStringTag;\n// Initialize this static property via an IIFE so bundlers don't tree-shake\n// out this logic, but also so we're still compliant with `\"sideEffects\": false`\nRecordBatch[_a] = (proto => {\n  proto._nullCount = -1;\n  proto[Symbol.isConcatSpreadable] = true;\n  return 'RecordBatch';\n})(RecordBatch.prototype);\n/** @ignore */\nfunction ensureSameLengthData(schema, chunks) {\n  let maxLength = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : chunks.reduce((max, col) => Math.max(max, col.length), 0);\n  var _b;\n  const fields = [...schema.fields];\n  const children = [...chunks];\n  const nullBitmapSize = (maxLength + 63 & ~63) >> 3;\n  for (const [idx, field] of schema.fields.entries()) {\n    const chunk = chunks[idx];\n    if (!chunk || chunk.length !== maxLength) {\n      fields[idx] = field.clone({\n        nullable: true\n      });\n      children[idx] = (_b = chunk === null || chunk === void 0 ? void 0 : chunk._changeLengthAndBackfillNullBitmap(maxLength)) !== null && _b !== void 0 ? _b : makeData({\n        type: field.type,\n        length: maxLength,\n        nullCount: maxLength,\n        nullBitmap: new Uint8Array(nullBitmapSize)\n      });\n    }\n  }\n  return [schema.assign(fields), makeData({\n    type: new Struct(fields),\n    length: maxLength,\n    children\n  })];\n}\n/** @ignore */\nfunction collectDictionaries(fields, children) {\n  let dictionaries = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Map();\n  for (let i = -1, n = fields.length; ++i < n;) {\n    const field = fields[i];\n    const type = field.type;\n    const data = children[i];\n    if (DataType.isDictionary(type)) {\n      if (!dictionaries.has(type.id)) {\n        if (data.dictionary) {\n          dictionaries.set(type.id, data.dictionary);\n        }\n      } else if (dictionaries.get(type.id) !== data.dictionary) {\n        throw new Error(\"Cannot create Schema containing two different dictionaries with the same Id\");\n      }\n    }\n    if (type.children && type.children.length > 0) {\n      collectDictionaries(type.children, data.children, dictionaries);\n    }\n  }\n  return dictionaries;\n}\n/**\n * An internal class used by the `RecordBatchReader` and `RecordBatchWriter`\n * implementations to differentiate between a stream with valid zero-length\n * RecordBatches, and a stream with a Schema message, but no RecordBatches.\n * @see https://github.com/apache/arrow/pull/4373\n * @ignore\n * @private\n */\nexport class _InternalEmptyPlaceholderRecordBatch extends RecordBatch {\n  constructor(schema) {\n    const children = schema.fields.map(f => makeData({\n      type: f.type\n    }));\n    const data = makeData({\n      type: new Struct(schema.fields),\n      nullCount: 0,\n      children\n    });\n    super(schema, data);\n  }\n}","map":{"version":3,"names":["Data","makeData","Table","Vector","Schema","Field","DataType","Struct","Null","instance","getVisitor","setVisitor","indexOfVisitor","iteratorVisitor","byteLengthVisitor","RecordBatch","constructor","_len","arguments","length","args","Array","_key","schema","TypeError","data","nullCount","type","fields","children","map","f","ensureSameLengthData","obj","Object","keys","reduce","memo","name","i","Math","max","new","nullable","dictionaries","_dictionaries","collectDictionaries","numCols","numRows","isValid","index","getValid","get","visit","set","value","indexOf","element","offset","getByteLength","Symbol","iterator","toArray","concat","_len2","others","_key2","slice","begin","end","getChild","getChildAt","_b","findIndex","setChild","child","setChildAt","field","clone","Map","metadata","select","columnNames","selectAt","columnIndices","filter","Boolean","subset","toStringTag","_a","proto","_nullCount","isConcatSpreadable","prototype","chunks","maxLength","undefined","col","nullBitmapSize","idx","entries","chunk","_changeLengthAndBackfillNullBitmap","nullBitmap","Uint8Array","assign","n","isDictionary","has","id","dictionary","Error","_InternalEmptyPlaceholderRecordBatch"],"sources":["C:\\Users\\mvlor\\OneDrive\\Desktop\\custom_component\\multi_menu\\template\\my_component\\frontend\\node_modules\\apache-arrow\\src\\recordbatch.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Data, makeData } from './data.js';\nimport { Table } from './table.js';\nimport { Vector } from './vector.js';\nimport { Schema, Field } from './schema.js';\nimport { DataType, Struct, Null, TypeMap } from './type.js';\n\nimport { instance as getVisitor } from './visitor/get.js';\nimport { instance as setVisitor } from './visitor/set.js';\nimport { instance as indexOfVisitor } from './visitor/indexof.js';\nimport { instance as iteratorVisitor } from './visitor/iterator.js';\nimport { instance as byteLengthVisitor } from './visitor/bytelength.js';\n\n/** @ignore */\nexport interface RecordBatch<T extends TypeMap = any> {\n    ///\n    // Virtual properties for the TypeScript compiler.\n    // These do not exist at runtime.\n    ///\n    readonly TType: Struct<T>;\n    readonly TArray: Struct<T>['TArray'];\n    readonly TValue: Struct<T>['TValue'];\n\n    /**\n     * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/isConcatSpreadable\n     */\n    [Symbol.isConcatSpreadable]: true;\n}\n\n/** @ignore */\nexport class RecordBatch<T extends TypeMap = any> {\n\n    constructor(columns: { [P in keyof T]: Data<T[P]> });\n    constructor(schema: Schema<T>, data?: Data<Struct<T>>);\n    constructor(...args: any[]) {\n        switch (args.length) {\n            case 2: {\n                [this.schema] = args;\n                if (!(this.schema instanceof Schema)) {\n                    throw new TypeError('RecordBatch constructor expects a [Schema, Data] pair.');\n                }\n                [,\n                    this.data = makeData({\n                        nullCount: 0,\n                        type: new Struct<T>(this.schema.fields),\n                        children: this.schema.fields.map((f) => makeData({ type: f.type, nullCount: 0 }))\n                    })\n                ] = args;\n                if (!(this.data instanceof Data)) {\n                    throw new TypeError('RecordBatch constructor expects a [Schema, Data] pair.');\n                }\n                [this.schema, this.data] = ensureSameLengthData<T>(this.schema, this.data.children as Data<T[keyof T]>[]);\n                break;\n            }\n            case 1: {\n                const [obj] = args;\n                const { fields, children, length } = Object.keys(obj).reduce((memo, name, i) => {\n                    memo.children[i] = obj[name];\n                    memo.length = Math.max(memo.length, obj[name].length);\n                    memo.fields[i] = Field.new({ name, type: obj[name].type, nullable: true });\n                    return memo;\n                }, {\n                    length: 0,\n                    fields: new Array<Field<T[keyof T]>>(),\n                    children: new Array<Data<T[keyof T]>>(),\n                });\n\n                const schema = new Schema<T>(fields);\n                const data = makeData({ type: new Struct<T>(fields), length, children, nullCount: 0 });\n                [this.schema, this.data] = ensureSameLengthData<T>(schema, data.children as Data<T[keyof T]>[], length);\n                break;\n            }\n            default: throw new TypeError('RecordBatch constructor expects an Object mapping names to child Data, or a [Schema, Data] pair.');\n        }\n    }\n\n    protected _dictionaries?: Map<number, Vector>;\n\n    public readonly schema: Schema<T>;\n    public readonly data: Data<Struct<T>>;\n\n    public get dictionaries() {\n        return this._dictionaries || (this._dictionaries = collectDictionaries(this.schema.fields, this.data.children));\n    }\n\n    /**\n     * The number of columns in this RecordBatch.\n     */\n    public get numCols() { return this.schema.fields.length; }\n\n    /**\n     * The number of rows in this RecordBatch.\n     */\n    public get numRows() { return this.data.length; }\n\n    /**\n     * The number of null rows in this RecordBatch.\n     */\n    public get nullCount() {\n        return this.data.nullCount;\n    }\n\n    /**\n     * Check whether an element is null.\n     * @param index The index at which to read the validity bitmap.\n     */\n    public isValid(index: number) {\n        return this.data.getValid(index);\n    }\n\n    /**\n     * Get a row by position.\n     * @param index The index of the element to read.\n     */\n    public get(index: number) {\n        return getVisitor.visit(this.data, index);\n    }\n\n    /**\n     * Set a row by position.\n     * @param index The index of the element to write.\n     * @param value The value to set.\n     */\n    public set(index: number, value: Struct<T>['TValue']) {\n        return setVisitor.visit(this.data, index, value);\n    }\n\n    /**\n     * Retrieve the index of the first occurrence of a row in an RecordBatch.\n     * @param element The row to locate in the RecordBatch.\n     * @param offset The index at which to begin the search. If offset is omitted, the search starts at index 0.\n     */\n    public indexOf(element: Struct<T>['TValue'], offset?: number): number {\n        return indexOfVisitor.visit(this.data, element, offset);\n    }\n\n    /**\n     * Get the size (in bytes) of a row by index.\n     * @param index The row index for which to compute the byteLength.\n     */\n    public getByteLength(index: number): number {\n        return byteLengthVisitor.visit(this.data, index);\n    }\n\n    /**\n     * Iterator for rows in this RecordBatch.\n     */\n    public [Symbol.iterator]() {\n        return iteratorVisitor.visit(new Vector([this.data])) as IterableIterator<Struct<T>['TValue']>;\n    }\n\n    /**\n     * Return a JavaScript Array of the RecordBatch rows.\n     * @returns An Array of RecordBatch rows.\n     */\n    public toArray() {\n        return [...this];\n    }\n\n    /**\n     * Combines two or more RecordBatch of the same schema.\n     * @param others Additional RecordBatch to add to the end of this RecordBatch.\n     */\n    public concat(...others: RecordBatch<T>[]) {\n        return new Table(this.schema, [this, ...others]);\n    }\n\n    /**\n     * Return a zero-copy sub-section of this RecordBatch.\n     * @param start The beginning of the specified portion of the RecordBatch.\n     * @param end The end of the specified portion of the RecordBatch. This is exclusive of the element at the index 'end'.\n     */\n    public slice(begin?: number, end?: number): RecordBatch<T> {\n        const [slice] = new Vector([this.data]).slice(begin, end).data;\n        return new RecordBatch(this.schema, slice);\n    }\n\n    /**\n     * Returns a child Vector by name, or null if this Vector has no child with the given name.\n     * @param name The name of the child to retrieve.\n     */\n    public getChild<P extends keyof T>(name: P) {\n        return this.getChildAt<T[P]>(this.schema.fields?.findIndex((f) => f.name === name));\n    }\n\n    /**\n     * Returns a child Vector by index, or null if this Vector has no child at the supplied index.\n     * @param index The index of the child to retrieve.\n     */\n    public getChildAt<R extends DataType = any>(index: number): Vector<R> | null {\n        if (index > -1 && index < this.schema.fields.length) {\n            return new Vector([this.data.children[index]]) as Vector<R>;\n        }\n        return null;\n    }\n\n    /**\n     * Sets a child Vector by name.\n     * @param name The name of the child to overwrite.\n     * @returns A new RecordBatch with the new child for the specified name.\n     */\n    public setChild<P extends keyof T, R extends DataType>(name: P, child: Vector<R>) {\n        return this.setChildAt(this.schema.fields?.findIndex((f) => f.name === name), child) as RecordBatch<T & { [K in P]: R }>;\n    }\n\n    /**\n     * Sets a child Vector by index.\n     * @param index The index of the child to overwrite.\n     * @returns A new RecordBatch with the new child at the specified index.\n     */\n    public setChildAt(index: number, child?: null): RecordBatch;\n    public setChildAt<R extends DataType = any>(index: number, child: Vector<R>): RecordBatch;\n    public setChildAt(index: number, child: any) {\n        let schema: Schema = this.schema;\n        let data: Data<Struct> = this.data;\n        if (index > -1 && index < this.numCols) {\n            if (!child) {\n                child = new Vector([makeData({ type: new Null, length: this.numRows })]);\n            }\n            const fields = schema.fields.slice() as Field<any>[];\n            const children = data.children.slice() as Data<any>[];\n            const field = fields[index].clone({ type: child.type });\n            [fields[index], children[index]] = [field, child.data[0]];\n            schema = new Schema(fields, new Map(this.schema.metadata));\n            data = makeData({ type: new Struct<T>(fields), children });\n        }\n        return new RecordBatch(schema, data);\n    }\n\n    /**\n     * Construct a new RecordBatch containing only specified columns.\n     *\n     * @param columnNames Names of columns to keep.\n     * @returns A new RecordBatch of columns matching the specified names.\n     */\n    public select<K extends keyof T = any>(columnNames: K[]) {\n        const schema = this.schema.select(columnNames);\n        const type = new Struct(schema.fields);\n        const children = [] as Data<T[K]>[];\n        for (const name of columnNames) {\n            const index = this.schema.fields.findIndex((f) => f.name === name);\n            if (~index) {\n                children[index] = this.data.children[index] as Data<T[K]>;\n            }\n        }\n        return new RecordBatch(schema, makeData({ type, length: this.numRows, children }));\n    }\n\n    /**\n     * Construct a new RecordBatch containing only columns at the specified indices.\n     *\n     * @param columnIndices Indices of columns to keep.\n     * @returns A new RecordBatch of columns matching at the specified indices.\n     */\n    public selectAt<K extends T = any>(columnIndices: number[]) {\n        const schema = this.schema.selectAt<K>(columnIndices);\n        const children = columnIndices.map((i) => this.data.children[i]).filter(Boolean);\n        const subset = makeData({ type: new Struct(schema.fields), length: this.numRows, children });\n        return new RecordBatch<{ [P in keyof K]: K[P] }>(schema, subset);\n    }\n\n    // Initialize this static property via an IIFE so bundlers don't tree-shake\n    // out this logic, but also so we're still compliant with `\"sideEffects\": false`\n    protected static [Symbol.toStringTag] = ((proto: RecordBatch) => {\n        (proto as any)._nullCount = -1;\n        (proto as any)[Symbol.isConcatSpreadable] = true;\n        return 'RecordBatch';\n    })(RecordBatch.prototype);\n}\n\n\n/** @ignore */\nfunction ensureSameLengthData<T extends TypeMap = any>(\n    schema: Schema<T>,\n    chunks: Data<T[keyof T]>[],\n    maxLength = chunks.reduce((max, col) => Math.max(max, col.length), 0)\n) {\n    const fields = [...schema.fields];\n    const children = [...chunks] as Data<T[keyof T]>[];\n    const nullBitmapSize = ((maxLength + 63) & ~63) >> 3;\n\n    for (const [idx, field] of schema.fields.entries()) {\n        const chunk = chunks[idx];\n        if (!chunk || chunk.length !== maxLength) {\n            fields[idx] = field.clone({ nullable: true });\n            children[idx] = chunk?._changeLengthAndBackfillNullBitmap(maxLength) ?? makeData({\n                type: field.type,\n                length: maxLength,\n                nullCount: maxLength,\n                nullBitmap: new Uint8Array(nullBitmapSize)\n            });\n        }\n    }\n\n    return [\n        schema.assign(fields),\n        makeData({ type: new Struct<T>(fields), length: maxLength, children })\n    ] as [Schema<T>, Data<Struct<T>>];\n}\n\n/** @ignore */\nfunction collectDictionaries(fields: Field[], children: Data[], dictionaries = new Map<number, Vector>()): Map<number, Vector> {\n    for (let i = -1, n = fields.length; ++i < n;) {\n        const field = fields[i];\n        const type = field.type;\n        const data = children[i];\n        if (DataType.isDictionary(type)) {\n            if (!dictionaries.has(type.id)) {\n                if (data.dictionary) {\n                    dictionaries.set(type.id, data.dictionary);\n                }\n            } else if (dictionaries.get(type.id) !== data.dictionary) {\n                throw new Error(`Cannot create Schema containing two different dictionaries with the same Id`);\n            }\n        }\n        if (type.children && type.children.length > 0) {\n            collectDictionaries(type.children, data.children, dictionaries);\n        }\n    }\n    return dictionaries;\n}\n\n/**\n * An internal class used by the `RecordBatchReader` and `RecordBatchWriter`\n * implementations to differentiate between a stream with valid zero-length\n * RecordBatches, and a stream with a Schema message, but no RecordBatches.\n * @see https://github.com/apache/arrow/pull/4373\n * @ignore\n * @private\n */\nexport class _InternalEmptyPlaceholderRecordBatch<T extends TypeMap = any> extends RecordBatch<T> {\n    constructor(schema: Schema<T>) {\n        const children = schema.fields.map((f) => makeData({ type: f.type }));\n        const data = makeData({ type: new Struct<T>(schema.fields), nullCount: 0, children });\n        super(schema, data);\n    }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASA,IAAI,EAAEC,QAAQ,QAAQ,YAAY;AAC3C,SAASC,KAAK,QAAQ,aAAa;AACnC,SAASC,MAAM,QAAQ,cAAc;AACrC,SAASC,MAAM,EAAEC,KAAK,QAAQ,cAAc;AAC5C,SAASC,QAAQ,EAAEC,MAAM,EAAEC,IAAI,QAAiB,YAAY;AAE5D,SAASC,QAAQ,IAAIC,UAAU,QAAQ,mBAAmB;AAC1D,SAASD,QAAQ,IAAIE,UAAU,QAAQ,mBAAmB;AAC1D,SAASF,QAAQ,IAAIG,cAAc,QAAQ,uBAAuB;AAClE,SAASH,QAAQ,IAAII,eAAe,QAAQ,wBAAwB;AACpE,SAASJ,QAAQ,IAAIK,iBAAiB,QAAQ,0BAA0B;AAkBxE;AACA,OAAM,MAAOC,WAAW;EAIpBC,YAAA,EAA0B;IAAA,SAAAC,IAAA,GAAAC,SAAA,CAAAC,MAAA,EAAXC,IAAW,OAAAC,KAAA,CAAAJ,IAAA,GAAAK,IAAA,MAAAA,IAAA,GAAAL,IAAA,EAAAK,IAAA;MAAXF,IAAW,CAAAE,IAAA,IAAAJ,SAAA,CAAAI,IAAA;IAAA;IACtB,QAAQF,IAAI,CAACD,MAAM;MACf,KAAK,CAAC;QAAE;UACJ,CAAC,IAAI,CAACI,MAAM,CAAC,GAAGH,IAAI;UACpB,IAAI,EAAE,IAAI,CAACG,MAAM,YAAYnB,MAAM,CAAC,EAAE;YAClC,MAAM,IAAIoB,SAAS,CAAC,wDAAwD,CAAC;;UAEjF,GACI,IAAI,CAACC,IAAI,GAAGxB,QAAQ,CAAC;YACjByB,SAAS,EAAE,CAAC;YACZC,IAAI,EAAE,IAAIpB,MAAM,CAAI,IAAI,CAACgB,MAAM,CAACK,MAAM,CAAC;YACvCC,QAAQ,EAAE,IAAI,CAACN,MAAM,CAACK,MAAM,CAACE,GAAG,CAAEC,CAAC,IAAK9B,QAAQ,CAAC;cAAE0B,IAAI,EAAEI,CAAC,CAACJ,IAAI;cAAED,SAAS,EAAE;YAAC,CAAE,CAAC;WACnF,CAAC,CACL,GAAGN,IAAI;UACR,IAAI,EAAE,IAAI,CAACK,IAAI,YAAYzB,IAAI,CAAC,EAAE;YAC9B,MAAM,IAAIwB,SAAS,CAAC,wDAAwD,CAAC;;UAEjF,CAAC,IAAI,CAACD,MAAM,EAAE,IAAI,CAACE,IAAI,CAAC,GAAGO,oBAAoB,CAAI,IAAI,CAACT,MAAM,EAAE,IAAI,CAACE,IAAI,CAACI,QAA8B,CAAC;UACzG;;MAEJ,KAAK,CAAC;QAAE;UACJ,MAAM,CAACI,GAAG,CAAC,GAAGb,IAAI;UAClB,MAAM;YAAEQ,MAAM;YAAEC,QAAQ;YAAEV;UAAM,CAAE,GAAGe,MAAM,CAACC,IAAI,CAACF,GAAG,CAAC,CAACG,MAAM,CAAC,CAACC,IAAI,EAAEC,IAAI,EAAEC,CAAC,KAAI;YAC3EF,IAAI,CAACR,QAAQ,CAACU,CAAC,CAAC,GAAGN,GAAG,CAACK,IAAI,CAAC;YAC5BD,IAAI,CAAClB,MAAM,GAAGqB,IAAI,CAACC,GAAG,CAACJ,IAAI,CAAClB,MAAM,EAAEc,GAAG,CAACK,IAAI,CAAC,CAACnB,MAAM,CAAC;YACrDkB,IAAI,CAACT,MAAM,CAACW,CAAC,CAAC,GAAGlC,KAAK,CAACqC,GAAG,CAAC;cAAEJ,IAAI;cAAEX,IAAI,EAAEM,GAAG,CAACK,IAAI,CAAC,CAACX,IAAI;cAAEgB,QAAQ,EAAE;YAAI,CAAE,CAAC;YAC1E,OAAON,IAAI;UACf,CAAC,EAAE;YACClB,MAAM,EAAE,CAAC;YACTS,MAAM,EAAE,IAAIP,KAAK,EAAqB;YACtCQ,QAAQ,EAAE,IAAIR,KAAK;WACtB,CAAC;UAEF,MAAME,MAAM,GAAG,IAAInB,MAAM,CAAIwB,MAAM,CAAC;UACpC,MAAMH,IAAI,GAAGxB,QAAQ,CAAC;YAAE0B,IAAI,EAAE,IAAIpB,MAAM,CAAIqB,MAAM,CAAC;YAAET,MAAM;YAAEU,QAAQ;YAAEH,SAAS,EAAE;UAAC,CAAE,CAAC;UACtF,CAAC,IAAI,CAACH,MAAM,EAAE,IAAI,CAACE,IAAI,CAAC,GAAGO,oBAAoB,CAAIT,MAAM,EAAEE,IAAI,CAACI,QAA8B,EAAEV,MAAM,CAAC;UACvG;;MAEJ;QAAS,MAAM,IAAIK,SAAS,CAAC,kGAAkG,CAAC;;EAExI;EAOA,IAAWoB,YAAYA,CAAA;IACnB,OAAO,IAAI,CAACC,aAAa,KAAK,IAAI,CAACA,aAAa,GAAGC,mBAAmB,CAAC,IAAI,CAACvB,MAAM,CAACK,MAAM,EAAE,IAAI,CAACH,IAAI,CAACI,QAAQ,CAAC,CAAC;EACnH;EAEA;;;EAGA,IAAWkB,OAAOA,CAAA;IAAK,OAAO,IAAI,CAACxB,MAAM,CAACK,MAAM,CAACT,MAAM;EAAE;EAEzD;;;EAGA,IAAW6B,OAAOA,CAAA;IAAK,OAAO,IAAI,CAACvB,IAAI,CAACN,MAAM;EAAE;EAEhD;;;EAGA,IAAWO,SAASA,CAAA;IAChB,OAAO,IAAI,CAACD,IAAI,CAACC,SAAS;EAC9B;EAEA;;;;EAIOuB,OAAOA,CAACC,KAAa;IACxB,OAAO,IAAI,CAACzB,IAAI,CAAC0B,QAAQ,CAACD,KAAK,CAAC;EACpC;EAEA;;;;EAIOE,GAAGA,CAACF,KAAa;IACpB,OAAOxC,UAAU,CAAC2C,KAAK,CAAC,IAAI,CAAC5B,IAAI,EAAEyB,KAAK,CAAC;EAC7C;EAEA;;;;;EAKOI,GAAGA,CAACJ,KAAa,EAAEK,KAA0B;IAChD,OAAO5C,UAAU,CAAC0C,KAAK,CAAC,IAAI,CAAC5B,IAAI,EAAEyB,KAAK,EAAEK,KAAK,CAAC;EACpD;EAEA;;;;;EAKOC,OAAOA,CAACC,OAA4B,EAAEC,MAAe;IACxD,OAAO9C,cAAc,CAACyC,KAAK,CAAC,IAAI,CAAC5B,IAAI,EAAEgC,OAAO,EAAEC,MAAM,CAAC;EAC3D;EAEA;;;;EAIOC,aAAaA,CAACT,KAAa;IAC9B,OAAOpC,iBAAiB,CAACuC,KAAK,CAAC,IAAI,CAAC5B,IAAI,EAAEyB,KAAK,CAAC;EACpD;EAEA;;;EAGO,CAACU,MAAM,CAACC,QAAQ,IAAC;IACpB,OAAOhD,eAAe,CAACwC,KAAK,CAAC,IAAIlD,MAAM,CAAC,CAAC,IAAI,CAACsB,IAAI,CAAC,CAAC,CAA0C;EAClG;EAEA;;;;EAIOqC,OAAOA,CAAA;IACV,OAAO,CAAC,GAAG,IAAI,CAAC;EACpB;EAEA;;;;EAIOC,MAAMA,CAAA,EAA4B;IAAA,SAAAC,KAAA,GAAA9C,SAAA,CAAAC,MAAA,EAAxB8C,MAAwB,OAAA5C,KAAA,CAAA2C,KAAA,GAAAE,KAAA,MAAAA,KAAA,GAAAF,KAAA,EAAAE,KAAA;MAAxBD,MAAwB,CAAAC,KAAA,IAAAhD,SAAA,CAAAgD,KAAA;IAAA;IACrC,OAAO,IAAIhE,KAAK,CAAC,IAAI,CAACqB,MAAM,EAAE,CAAC,IAAI,EAAE,GAAG0C,MAAM,CAAC,CAAC;EACpD;EAEA;;;;;EAKOE,KAAKA,CAACC,KAAc,EAAEC,GAAY;IACrC,MAAM,CAACF,KAAK,CAAC,GAAG,IAAIhE,MAAM,CAAC,CAAC,IAAI,CAACsB,IAAI,CAAC,CAAC,CAAC0C,KAAK,CAACC,KAAK,EAAEC,GAAG,CAAC,CAAC5C,IAAI;IAC9D,OAAO,IAAIV,WAAW,CAAC,IAAI,CAACQ,MAAM,EAAE4C,KAAK,CAAC;EAC9C;EAEA;;;;EAIOG,QAAQA,CAAoBhC,IAAO;;IACtC,OAAO,IAAI,CAACiC,UAAU,CAAO,CAAAC,EAAA,OAAI,CAACjD,MAAM,CAACK,MAAM,cAAA4C,EAAA,uBAAAA,EAAA,CAAEC,SAAS,CAAE1C,CAAC,IAAKA,CAAC,CAACO,IAAI,KAAKA,IAAI,CAAC,CAAC;EACvF;EAEA;;;;EAIOiC,UAAUA,CAA2BrB,KAAa;IACrD,IAAIA,KAAK,GAAG,CAAC,CAAC,IAAIA,KAAK,GAAG,IAAI,CAAC3B,MAAM,CAACK,MAAM,CAACT,MAAM,EAAE;MACjD,OAAO,IAAIhB,MAAM,CAAC,CAAC,IAAI,CAACsB,IAAI,CAACI,QAAQ,CAACqB,KAAK,CAAC,CAAC,CAAc;;IAE/D,OAAO,IAAI;EACf;EAEA;;;;;EAKOwB,QAAQA,CAAwCpC,IAAO,EAAEqC,KAAgB;;IAC5E,OAAO,IAAI,CAACC,UAAU,CAAC,CAAAJ,EAAA,OAAI,CAACjD,MAAM,CAACK,MAAM,cAAA4C,EAAA,uBAAAA,EAAA,CAAEC,SAAS,CAAE1C,CAAC,IAAKA,CAAC,CAACO,IAAI,KAAKA,IAAI,CAAC,EAAEqC,KAAK,CAAqC;EAC5H;EASOC,UAAUA,CAAC1B,KAAa,EAAEyB,KAAU;IACvC,IAAIpD,MAAM,GAAW,IAAI,CAACA,MAAM;IAChC,IAAIE,IAAI,GAAiB,IAAI,CAACA,IAAI;IAClC,IAAIyB,KAAK,GAAG,CAAC,CAAC,IAAIA,KAAK,GAAG,IAAI,CAACH,OAAO,EAAE;MACpC,IAAI,CAAC4B,KAAK,EAAE;QACRA,KAAK,GAAG,IAAIxE,MAAM,CAAC,CAACF,QAAQ,CAAC;UAAE0B,IAAI,EAAE,IAAInB,IAAI,CAAJ,CAAI;UAAEW,MAAM,EAAE,IAAI,CAAC6B;QAAO,CAAE,CAAC,CAAC,CAAC;;MAE5E,MAAMpB,MAAM,GAAGL,MAAM,CAACK,MAAM,CAACuC,KAAK,EAAkB;MACpD,MAAMtC,QAAQ,GAAGJ,IAAI,CAACI,QAAQ,CAACsC,KAAK,EAAiB;MACrD,MAAMU,KAAK,GAAGjD,MAAM,CAACsB,KAAK,CAAC,CAAC4B,KAAK,CAAC;QAAEnD,IAAI,EAAEgD,KAAK,CAAChD;MAAI,CAAE,CAAC;MACvD,CAACC,MAAM,CAACsB,KAAK,CAAC,EAAErB,QAAQ,CAACqB,KAAK,CAAC,CAAC,GAAG,CAAC2B,KAAK,EAAEF,KAAK,CAAClD,IAAI,CAAC,CAAC,CAAC,CAAC;MACzDF,MAAM,GAAG,IAAInB,MAAM,CAACwB,MAAM,EAAE,IAAImD,GAAG,CAAC,IAAI,CAACxD,MAAM,CAACyD,QAAQ,CAAC,CAAC;MAC1DvD,IAAI,GAAGxB,QAAQ,CAAC;QAAE0B,IAAI,EAAE,IAAIpB,MAAM,CAAIqB,MAAM,CAAC;QAAEC;MAAQ,CAAE,CAAC;;IAE9D,OAAO,IAAId,WAAW,CAACQ,MAAM,EAAEE,IAAI,CAAC;EACxC;EAEA;;;;;;EAMOwD,MAAMA,CAA0BC,WAAgB;IACnD,MAAM3D,MAAM,GAAG,IAAI,CAACA,MAAM,CAAC0D,MAAM,CAACC,WAAW,CAAC;IAC9C,MAAMvD,IAAI,GAAG,IAAIpB,MAAM,CAACgB,MAAM,CAACK,MAAM,CAAC;IACtC,MAAMC,QAAQ,GAAG,EAAkB;IACnC,KAAK,MAAMS,IAAI,IAAI4C,WAAW,EAAE;MAC5B,MAAMhC,KAAK,GAAG,IAAI,CAAC3B,MAAM,CAACK,MAAM,CAAC6C,SAAS,CAAE1C,CAAC,IAAKA,CAAC,CAACO,IAAI,KAAKA,IAAI,CAAC;MAClE,IAAI,CAACY,KAAK,EAAE;QACRrB,QAAQ,CAACqB,KAAK,CAAC,GAAG,IAAI,CAACzB,IAAI,CAACI,QAAQ,CAACqB,KAAK,CAAe;;;IAGjE,OAAO,IAAInC,WAAW,CAACQ,MAAM,EAAEtB,QAAQ,CAAC;MAAE0B,IAAI;MAAER,MAAM,EAAE,IAAI,CAAC6B,OAAO;MAAEnB;IAAQ,CAAE,CAAC,CAAC;EACtF;EAEA;;;;;;EAMOsD,QAAQA,CAAoBC,aAAuB;IACtD,MAAM7D,MAAM,GAAG,IAAI,CAACA,MAAM,CAAC4D,QAAQ,CAAIC,aAAa,CAAC;IACrD,MAAMvD,QAAQ,GAAGuD,aAAa,CAACtD,GAAG,CAAES,CAAC,IAAK,IAAI,CAACd,IAAI,CAACI,QAAQ,CAACU,CAAC,CAAC,CAAC,CAAC8C,MAAM,CAACC,OAAO,CAAC;IAChF,MAAMC,MAAM,GAAGtF,QAAQ,CAAC;MAAE0B,IAAI,EAAE,IAAIpB,MAAM,CAACgB,MAAM,CAACK,MAAM,CAAC;MAAET,MAAM,EAAE,IAAI,CAAC6B,OAAO;MAAEnB;IAAQ,CAAE,CAAC;IAC5F,OAAO,IAAId,WAAW,CAA2BQ,MAAM,EAAEgE,MAAM,CAAC;EACpE;;KAIkB3B,MAAM,CAAC4B,WAAW;AAFpC;AACA;AACiBzE,WAAA,CAAA0E,EAAA,CAAoB,GAAG,CAAEC,KAAkB,IAAI;EAC3DA,KAAa,CAACC,UAAU,GAAG,CAAC,CAAC;EAC7BD,KAAa,CAAC9B,MAAM,CAACgC,kBAAkB,CAAC,GAAG,IAAI;EAChD,OAAO,aAAa;AACxB,CAAC,EAAE7E,WAAW,CAAC8E,SAAS,CAAC;AAI7B;AACA,SAAS7D,oBAAoBA,CACzBT,MAAiB,EACjBuE,MAA0B,EAC2C;EAAA,IAArEC,SAAS,GAAA7E,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAA8E,SAAA,GAAA9E,SAAA,MAAG4E,MAAM,CAAC1D,MAAM,CAAC,CAACK,GAAG,EAAEwD,GAAG,KAAKzD,IAAI,CAACC,GAAG,CAACA,GAAG,EAAEwD,GAAG,CAAC9E,MAAM,CAAC,EAAE,CAAC,CAAC;;EAErE,MAAMS,MAAM,GAAG,CAAC,GAAGL,MAAM,CAACK,MAAM,CAAC;EACjC,MAAMC,QAAQ,GAAG,CAAC,GAAGiE,MAAM,CAAuB;EAClD,MAAMI,cAAc,GAAG,CAAEH,SAAS,GAAG,EAAE,GAAI,CAAC,EAAE,KAAK,CAAC;EAEpD,KAAK,MAAM,CAACI,GAAG,EAAEtB,KAAK,CAAC,IAAItD,MAAM,CAACK,MAAM,CAACwE,OAAO,EAAE,EAAE;IAChD,MAAMC,KAAK,GAAGP,MAAM,CAACK,GAAG,CAAC;IACzB,IAAI,CAACE,KAAK,IAAIA,KAAK,CAAClF,MAAM,KAAK4E,SAAS,EAAE;MACtCnE,MAAM,CAACuE,GAAG,CAAC,GAAGtB,KAAK,CAACC,KAAK,CAAC;QAAEnC,QAAQ,EAAE;MAAI,CAAE,CAAC;MAC7Cd,QAAQ,CAACsE,GAAG,CAAC,GAAG,CAAA3B,EAAA,GAAA6B,KAAK,aAALA,KAAK,uBAALA,KAAK,CAAEC,kCAAkC,CAACP,SAAS,CAAC,cAAAvB,EAAA,cAAAA,EAAA,GAAIvE,QAAQ,CAAC;QAC7E0B,IAAI,EAAEkD,KAAK,CAAClD,IAAI;QAChBR,MAAM,EAAE4E,SAAS;QACjBrE,SAAS,EAAEqE,SAAS;QACpBQ,UAAU,EAAE,IAAIC,UAAU,CAACN,cAAc;OAC5C,CAAC;;;EAIV,OAAO,CACH3E,MAAM,CAACkF,MAAM,CAAC7E,MAAM,CAAC,EACrB3B,QAAQ,CAAC;IAAE0B,IAAI,EAAE,IAAIpB,MAAM,CAAIqB,MAAM,CAAC;IAAET,MAAM,EAAE4E,SAAS;IAAElE;EAAQ,CAAE,CAAC,CACzC;AACrC;AAEA;AACA,SAASiB,mBAAmBA,CAAClB,MAAe,EAAEC,QAAgB,EAA0C;EAAA,IAAxCe,YAAA,GAAA1B,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAA8E,SAAA,GAAA9E,SAAA,MAAe,IAAI6D,GAAG,EAAkB;EACpG,KAAK,IAAIxC,CAAC,GAAG,CAAC,CAAC,EAAEmE,CAAC,GAAG9E,MAAM,CAACT,MAAM,EAAE,EAAEoB,CAAC,GAAGmE,CAAC,GAAG;IAC1C,MAAM7B,KAAK,GAAGjD,MAAM,CAACW,CAAC,CAAC;IACvB,MAAMZ,IAAI,GAAGkD,KAAK,CAAClD,IAAI;IACvB,MAAMF,IAAI,GAAGI,QAAQ,CAACU,CAAC,CAAC;IACxB,IAAIjC,QAAQ,CAACqG,YAAY,CAAChF,IAAI,CAAC,EAAE;MAC7B,IAAI,CAACiB,YAAY,CAACgE,GAAG,CAACjF,IAAI,CAACkF,EAAE,CAAC,EAAE;QAC5B,IAAIpF,IAAI,CAACqF,UAAU,EAAE;UACjBlE,YAAY,CAACU,GAAG,CAAC3B,IAAI,CAACkF,EAAE,EAAEpF,IAAI,CAACqF,UAAU,CAAC;;OAEjD,MAAM,IAAIlE,YAAY,CAACQ,GAAG,CAACzB,IAAI,CAACkF,EAAE,CAAC,KAAKpF,IAAI,CAACqF,UAAU,EAAE;QACtD,MAAM,IAAIC,KAAK,8EAA8E,CAAC;;;IAGtG,IAAIpF,IAAI,CAACE,QAAQ,IAAIF,IAAI,CAACE,QAAQ,CAACV,MAAM,GAAG,CAAC,EAAE;MAC3C2B,mBAAmB,CAACnB,IAAI,CAACE,QAAQ,EAAEJ,IAAI,CAACI,QAAQ,EAAEe,YAAY,CAAC;;;EAGvE,OAAOA,YAAY;AACvB;AAEA;;;;;;;;AAQA,OAAM,MAAOoE,oCAA8D,SAAQjG,WAAc;EAC7FC,YAAYO,MAAiB;IACzB,MAAMM,QAAQ,GAAGN,MAAM,CAACK,MAAM,CAACE,GAAG,CAAEC,CAAC,IAAK9B,QAAQ,CAAC;MAAE0B,IAAI,EAAEI,CAAC,CAACJ;IAAI,CAAE,CAAC,CAAC;IACrE,MAAMF,IAAI,GAAGxB,QAAQ,CAAC;MAAE0B,IAAI,EAAE,IAAIpB,MAAM,CAAIgB,MAAM,CAACK,MAAM,CAAC;MAAEF,SAAS,EAAE,CAAC;MAAEG;IAAQ,CAAE,CAAC;IACrF,KAAK,CAACN,MAAM,EAAEE,IAAI,CAAC;EACvB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}