{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { __rest } from \"tslib\";\nimport { makeBuilder } from '../../factories.mjs';\n/** @ignore */\nexport function builderThroughDOMStream(options) {\n  return new BuilderTransform(options);\n}\n/** @ignore */\nexport class BuilderTransform {\n  constructor(options) {\n    // Access properties by string indexers to defeat closure compiler\n    this._numChunks = 0;\n    this._finished = false;\n    this._bufferedSize = 0;\n    const {\n        ['readableStrategy']: readableStrategy,\n        ['writableStrategy']: writableStrategy,\n        ['queueingStrategy']: queueingStrategy = 'count'\n      } = options,\n      builderOptions = __rest(options, ['readableStrategy', 'writableStrategy', 'queueingStrategy']);\n    this._controller = null;\n    this._builder = makeBuilder(builderOptions);\n    this._getSize = queueingStrategy !== 'bytes' ? chunkLength : chunkByteLength;\n    const {\n      ['highWaterMark']: readableHighWaterMark = queueingStrategy === 'bytes' ? Math.pow(2, 14) : 1000\n    } = Object.assign({}, readableStrategy);\n    const {\n      ['highWaterMark']: writableHighWaterMark = queueingStrategy === 'bytes' ? Math.pow(2, 14) : 1000\n    } = Object.assign({}, writableStrategy);\n    this['readable'] = new ReadableStream({\n      ['cancel']: () => {\n        this._builder.clear();\n      },\n      ['pull']: c => {\n        this._maybeFlush(this._builder, this._controller = c);\n      },\n      ['start']: c => {\n        this._maybeFlush(this._builder, this._controller = c);\n      }\n    }, {\n      'highWaterMark': readableHighWaterMark,\n      'size': queueingStrategy !== 'bytes' ? chunkLength : chunkByteLength\n    });\n    this['writable'] = new WritableStream({\n      ['abort']: () => {\n        this._builder.clear();\n      },\n      ['write']: () => {\n        this._maybeFlush(this._builder, this._controller);\n      },\n      ['close']: () => {\n        this._maybeFlush(this._builder.finish(), this._controller);\n      }\n    }, {\n      'highWaterMark': writableHighWaterMark,\n      'size': value => this._writeValueAndReturnChunkSize(value)\n    });\n  }\n  _writeValueAndReturnChunkSize(value) {\n    const bufferedSize = this._bufferedSize;\n    this._bufferedSize = this._getSize(this._builder.append(value));\n    return this._bufferedSize - bufferedSize;\n  }\n  _maybeFlush(builder, controller) {\n    if (controller == null) {\n      return;\n    }\n    if (this._bufferedSize >= controller.desiredSize) {\n      ++this._numChunks && this._enqueue(controller, builder.toVector());\n    }\n    if (builder.finished) {\n      if (builder.length > 0 || this._numChunks === 0) {\n        ++this._numChunks && this._enqueue(controller, builder.toVector());\n      }\n      if (!this._finished && (this._finished = true)) {\n        this._enqueue(controller, null);\n      }\n    }\n  }\n  _enqueue(controller, chunk) {\n    this._bufferedSize = 0;\n    this._controller = null;\n    chunk == null ? controller.close() : controller.enqueue(chunk);\n  }\n}\n/** @ignore */\nconst chunkLength = chunk => {\n  var _a;\n  return (_a = chunk === null || chunk === void 0 ? void 0 : chunk.length) !== null && _a !== void 0 ? _a : 0;\n};\n/** @ignore */\nconst chunkByteLength = chunk => {\n  var _a;\n  return (_a = chunk === null || chunk === void 0 ? void 0 : chunk.byteLength) !== null && _a !== void 0 ? _a : 0;\n};","map":{"version":3,"names":["makeBuilder","builderThroughDOMStream","options","BuilderTransform","constructor","_numChunks","_finished","_bufferedSize","readableStrategy","writableStrategy","queueingStrategy","builderOptions","__rest","_controller","_builder","_getSize","chunkLength","chunkByteLength","readableHighWaterMark","Math","pow","Object","assign","writableHighWaterMark","ReadableStream","cancel","clear","c","_maybeFlush","WritableStream","abort","write","close","finish","value","_writeValueAndReturnChunkSize","bufferedSize","append","builder","controller","desiredSize","_enqueue","toVector","finished","length","chunk","enqueue","_a","byteLength"],"sources":["C:\\Users\\mvlor\\OneDrive\\Desktop\\custom_component\\streamlit_multi_menu\\streamlit_multi_menu\\frontend\\node_modules\\apache-arrow\\src\\io\\whatwg\\builder.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { DataType } from '../../type.js';\nimport { Vector } from '../../vector.js';\nimport { Builder, BuilderOptions } from '../../builder.js';\nimport { makeBuilder } from '../../factories.js';\n\n/** @ignore */\nexport interface BuilderTransformOptions<T extends DataType = any, TNull = any> extends BuilderOptions<T, TNull> {\n    queueingStrategy?: 'bytes' | 'count';\n    dictionaryHashFunction?: (value: any) => string | number;\n    readableStrategy?: { highWaterMark?: number; size?: any; type?: 'bytes' };\n    writableStrategy?: { highWaterMark?: number; size?: any; type?: 'bytes' };\n    valueToChildTypeId?: (builder: Builder<T, TNull>, value: any, offset: number) => number;\n}\n\n/** @ignore */\nexport function builderThroughDOMStream<T extends DataType = any, TNull = any>(options: BuilderTransformOptions<T, TNull>) {\n    return new BuilderTransform(options);\n}\n\n/** @ignore */\nexport class BuilderTransform<T extends DataType = any, TNull = any> {\n\n    public readable: ReadableStream<Vector<T>>;\n    public writable: WritableStream<T['TValue'] | TNull>;\n    public _controller: ReadableStreamDefaultController<Vector<T>> | null;\n\n    private _numChunks = 0;\n    private _finished = false;\n    private _bufferedSize = 0;\n    private _builder: Builder<T, TNull>;\n    private _getSize: (builder: Builder<T, TNull>) => number;\n\n    constructor(options: BuilderTransformOptions<T, TNull>) {\n\n        // Access properties by string indexers to defeat closure compiler\n\n        const {\n            ['readableStrategy']: readableStrategy,\n            ['writableStrategy']: writableStrategy,\n            ['queueingStrategy']: queueingStrategy = 'count',\n            ...builderOptions\n        } = options;\n\n        this._controller = null;\n        this._builder = makeBuilder<T, TNull>(builderOptions);\n        this._getSize = queueingStrategy !== 'bytes' ? chunkLength : chunkByteLength;\n\n        const { ['highWaterMark']: readableHighWaterMark = queueingStrategy === 'bytes' ? 2 ** 14 : 1000 } = { ...readableStrategy };\n        const { ['highWaterMark']: writableHighWaterMark = queueingStrategy === 'bytes' ? 2 ** 14 : 1000 } = { ...writableStrategy };\n\n        this['readable'] = new ReadableStream<Vector<T>>({\n            ['cancel']: () => { this._builder.clear(); },\n            ['pull']: (c) => { this._maybeFlush(this._builder, this._controller = c); },\n            ['start']: (c) => { this._maybeFlush(this._builder, this._controller = c); },\n        }, {\n            'highWaterMark': readableHighWaterMark,\n            'size': queueingStrategy !== 'bytes' ? chunkLength : chunkByteLength,\n        });\n\n        this['writable'] = new WritableStream({\n            ['abort']: () => { this._builder.clear(); },\n            ['write']: () => { this._maybeFlush(this._builder, this._controller); },\n            ['close']: () => { this._maybeFlush(this._builder.finish(), this._controller); },\n        }, {\n            'highWaterMark': writableHighWaterMark,\n            'size': (value: T['TValue'] | TNull) => this._writeValueAndReturnChunkSize(value),\n        });\n    }\n\n    private _writeValueAndReturnChunkSize(value: T['TValue'] | TNull) {\n        const bufferedSize = this._bufferedSize;\n        this._bufferedSize = this._getSize(this._builder.append(value));\n        return this._bufferedSize - bufferedSize;\n    }\n\n    private _maybeFlush(builder: Builder<T, TNull>, controller: ReadableStreamDefaultController<Vector<T>> | null) {\n        if (controller == null) { return; }\n        if (this._bufferedSize >= controller.desiredSize!) {\n            ++this._numChunks && this._enqueue(controller, builder.toVector());\n        }\n        if (builder.finished) {\n            if (builder.length > 0 || this._numChunks === 0) {\n                ++this._numChunks && this._enqueue(controller, builder.toVector());\n            }\n            if (!this._finished && (this._finished = true)) {\n                this._enqueue(controller, null);\n            }\n        }\n    }\n\n    private _enqueue(controller: ReadableStreamDefaultController<Vector<T>>, chunk: Vector<T> | null) {\n        this._bufferedSize = 0;\n        this._controller = null;\n        chunk == null ? controller.close() : controller.enqueue(chunk);\n    }\n}\n\n/** @ignore */ const chunkLength = <T extends DataType = any>(chunk?: Vector<T> | Builder<T>) => chunk?.length ?? 0;\n/** @ignore */ const chunkByteLength = <T extends DataType = any>(chunk?: Vector<T> | Builder<T>) => chunk?.byteLength ?? 0;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}