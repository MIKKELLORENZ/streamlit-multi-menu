{"ast":null,"code":"// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\nimport { __asyncGenerator, __asyncValues, __await } from \"tslib\";\nimport { Field, Schema } from './schema.mjs';\nimport * as dtypes from './type.mjs';\nimport { Data } from './data.mjs';\nimport { Vector, makeVector } from './vector.mjs';\nimport { instance as getBuilderConstructor } from './visitor/builderctor.mjs';\nimport { Table } from './table.mjs';\nimport { RecordBatch } from './recordbatch.mjs';\nimport { compareTypes } from './visitor/typecomparator.mjs';\nexport function makeBuilder(options) {\n  const type = options.type;\n  const builder = new (getBuilderConstructor.getVisitFn(type)())(options);\n  if (type.children && type.children.length > 0) {\n    const children = options['children'] || [];\n    const defaultOptions = {\n      'nullValues': options['nullValues']\n    };\n    const getChildOptions = Array.isArray(children) ? (_, i) => children[i] || defaultOptions : _ref => {\n      let {\n        name\n      } = _ref;\n      return children[name] || defaultOptions;\n    };\n    for (const [index, field] of type.children.entries()) {\n      const {\n        type\n      } = field;\n      const opts = getChildOptions(field, index);\n      builder.children.push(makeBuilder(Object.assign(Object.assign({}, opts), {\n        type\n      })));\n    }\n  }\n  return builder;\n}\nexport function vectorFromArray(init, type) {\n  if (init instanceof Data || init instanceof Vector || init.type instanceof dtypes.DataType || ArrayBuffer.isView(init)) {\n    return makeVector(init);\n  }\n  const options = {\n    type: type !== null && type !== void 0 ? type : inferType(init),\n    nullValues: [null]\n  };\n  const chunks = [...builderThroughIterable(options)(init)];\n  const vector = chunks.length === 1 ? chunks[0] : chunks.reduce((a, b) => a.concat(b));\n  if (dtypes.DataType.isDictionary(vector.type)) {\n    return vector.memoize();\n  }\n  return vector;\n}\n/**\n * Creates a {@link Table} from an array of objects.\n *\n * @param array A table of objects.\n */\nexport function tableFromJSON(array) {\n  const vector = vectorFromArray(array);\n  const batch = new RecordBatch(new Schema(vector.type.children), vector.data[0]);\n  return new Table(batch);\n}\nfunction inferType(value) {\n  if (value.length === 0) {\n    return new dtypes.Null();\n  }\n  let nullsCount = 0;\n  let arraysCount = 0;\n  let objectsCount = 0;\n  let numbersCount = 0;\n  let stringsCount = 0;\n  let bigintsCount = 0;\n  let booleansCount = 0;\n  let datesCount = 0;\n  for (const val of value) {\n    if (val == null) {\n      ++nullsCount;\n      continue;\n    }\n    switch (typeof val) {\n      case 'bigint':\n        ++bigintsCount;\n        continue;\n      case 'boolean':\n        ++booleansCount;\n        continue;\n      case 'number':\n        ++numbersCount;\n        continue;\n      case 'string':\n        ++stringsCount;\n        continue;\n      case 'object':\n        if (Array.isArray(val)) {\n          ++arraysCount;\n        } else if (Object.prototype.toString.call(val) === '[object Date]') {\n          ++datesCount;\n        } else {\n          ++objectsCount;\n        }\n        continue;\n    }\n    throw new TypeError('Unable to infer Vector type from input values, explicit type declaration expected');\n  }\n  if (numbersCount + nullsCount === value.length) {\n    return new dtypes.Float64();\n  } else if (stringsCount + nullsCount === value.length) {\n    return new dtypes.Dictionary(new dtypes.Utf8(), new dtypes.Int32());\n  } else if (bigintsCount + nullsCount === value.length) {\n    return new dtypes.Int64();\n  } else if (booleansCount + nullsCount === value.length) {\n    return new dtypes.Bool();\n  } else if (datesCount + nullsCount === value.length) {\n    return new dtypes.DateMillisecond();\n  } else if (arraysCount + nullsCount === value.length) {\n    const array = value;\n    const childType = inferType(array[array.findIndex(ary => ary != null)]);\n    if (array.every(ary => ary == null || compareTypes(childType, inferType(ary)))) {\n      return new dtypes.List(new Field('', childType, true));\n    }\n  } else if (objectsCount + nullsCount === value.length) {\n    const fields = new Map();\n    for (const row of value) {\n      for (const key of Object.keys(row)) {\n        if (!fields.has(key) && row[key] != null) {\n          // use the type inferred for the first instance of a found key\n          fields.set(key, new Field(key, inferType([row[key]]), true));\n        }\n      }\n    }\n    return new dtypes.Struct([...fields.values()]);\n  }\n  throw new TypeError('Unable to infer Vector type from input values, explicit type declaration expected');\n}\n/**\n * Transform a synchronous `Iterable` of arbitrary JavaScript values into a\n * sequence of Arrow Vector<T> following the chunking semantics defined in\n * the supplied `options` argument.\n *\n * This function returns a function that accepts an `Iterable` of values to\n * transform. When called, this function returns an Iterator of `Vector<T>`.\n *\n * The resulting `Iterator<Vector<T>>` yields Vectors based on the\n * `queueingStrategy` and `highWaterMark` specified in the `options` argument.\n *\n * * If `queueingStrategy` is `\"count\"` (or omitted), The `Iterator<Vector<T>>`\n *   will flush the underlying `Builder` (and yield a new `Vector<T>`) once the\n *   Builder's `length` reaches or exceeds the supplied `highWaterMark`.\n * * If `queueingStrategy` is `\"bytes\"`, the `Iterator<Vector<T>>` will flush\n *   the underlying `Builder` (and yield a new `Vector<T>`) once its `byteLength`\n *   reaches or exceeds the supplied `highWaterMark`.\n *\n * @param {IterableBuilderOptions<T, TNull>} options An object of properties which determine the `Builder` to create and the chunking semantics to use.\n * @returns A function which accepts a JavaScript `Iterable` of values to\n *          write, and returns an `Iterator` that yields Vectors according\n *          to the chunking semantics defined in the `options` argument.\n * @nocollapse\n */\nexport function builderThroughIterable(options) {\n  const {\n    ['queueingStrategy']: queueingStrategy = 'count'\n  } = options;\n  const {\n    ['highWaterMark']: highWaterMark = queueingStrategy !== 'bytes' ? Number.POSITIVE_INFINITY : Math.pow(2, 14)\n  } = options;\n  const sizeProperty = queueingStrategy !== 'bytes' ? 'length' : 'byteLength';\n  return function* (source) {\n    let numChunks = 0;\n    const builder = makeBuilder(options);\n    for (const value of source) {\n      if (builder.append(value)[sizeProperty] >= highWaterMark) {\n        ++numChunks && (yield builder.toVector());\n      }\n    }\n    if (builder.finish().length > 0 || numChunks === 0) {\n      yield builder.toVector();\n    }\n  };\n}\n/**\n * Transform an `AsyncIterable` of arbitrary JavaScript values into a\n * sequence of Arrow Vector<T> following the chunking semantics defined in\n * the supplied `options` argument.\n *\n * This function returns a function that accepts an `AsyncIterable` of values to\n * transform. When called, this function returns an AsyncIterator of `Vector<T>`.\n *\n * The resulting `AsyncIterator<Vector<T>>` yields Vectors based on the\n * `queueingStrategy` and `highWaterMark` specified in the `options` argument.\n *\n * * If `queueingStrategy` is `\"count\"` (or omitted), The `AsyncIterator<Vector<T>>`\n *   will flush the underlying `Builder` (and yield a new `Vector<T>`) once the\n *   Builder's `length` reaches or exceeds the supplied `highWaterMark`.\n * * If `queueingStrategy` is `\"bytes\"`, the `AsyncIterator<Vector<T>>` will flush\n *   the underlying `Builder` (and yield a new `Vector<T>`) once its `byteLength`\n *   reaches or exceeds the supplied `highWaterMark`.\n *\n * @param {IterableBuilderOptions<T, TNull>} options An object of properties which determine the `Builder` to create and the chunking semantics to use.\n * @returns A function which accepts a JavaScript `AsyncIterable` of values\n *          to write, and returns an `AsyncIterator` that yields Vectors\n *          according to the chunking semantics defined in the `options`\n *          argument.\n * @nocollapse\n */\nexport function builderThroughAsyncIterable(options) {\n  const {\n    ['queueingStrategy']: queueingStrategy = 'count'\n  } = options;\n  const {\n    ['highWaterMark']: highWaterMark = queueingStrategy !== 'bytes' ? Number.POSITIVE_INFINITY : Math.pow(2, 14)\n  } = options;\n  const sizeProperty = queueingStrategy !== 'bytes' ? 'length' : 'byteLength';\n  return function (source) {\n    return __asyncGenerator(this, arguments, function* () {\n      var e_1, _a;\n      let numChunks = 0;\n      const builder = makeBuilder(options);\n      try {\n        for (var source_1 = __asyncValues(source), source_1_1; source_1_1 = yield __await(source_1.next()), !source_1_1.done;) {\n          const value = source_1_1.value;\n          if (builder.append(value)[sizeProperty] >= highWaterMark) {\n            ++numChunks && (yield yield __await(builder.toVector()));\n          }\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (source_1_1 && !source_1_1.done && (_a = source_1.return)) yield __await(_a.call(source_1));\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n      if (builder.finish().length > 0 || numChunks === 0) {\n        yield yield __await(builder.toVector());\n      }\n    });\n  };\n}","map":{"version":3,"names":["Field","Schema","dtypes","Data","Vector","makeVector","instance","getBuilderConstructor","Table","RecordBatch","compareTypes","makeBuilder","options","type","builder","getVisitFn","children","length","defaultOptions","getChildOptions","Array","isArray","_","i","_ref","name","index","field","entries","opts","push","Object","assign","vectorFromArray","init","DataType","ArrayBuffer","isView","inferType","nullValues","chunks","builderThroughIterable","vector","reduce","a","b","concat","isDictionary","memoize","tableFromJSON","array","batch","data","value","Null","nullsCount","arraysCount","objectsCount","numbersCount","stringsCount","bigintsCount","booleansCount","datesCount","val","prototype","toString","call","TypeError","Float64","Dictionary","Utf8","Int32","Int64","Bool","DateMillisecond","childType","findIndex","ary","every","List","fields","Map","row","key","keys","has","set","Struct","values","queueingStrategy","highWaterMark","Number","POSITIVE_INFINITY","Math","pow","sizeProperty","source","numChunks","append","toVector","finish","builderThroughAsyncIterable","source_1","__asyncValues","source_1_1","__await","next","done"],"sources":["C:\\Users\\mvlor\\OneDrive\\Desktop\\custom_component\\multi_menu\\template\\multi_menu\\frontend\\node_modules\\apache-arrow\\src\\factories.ts"],"sourcesContent":["// Licensed to the Apache Software Foundation (ASF) under one\n// or more contributor license agreements.  See the NOTICE file\n// distributed with this work for additional information\n// regarding copyright ownership.  The ASF licenses this file\n// to you under the Apache License, Version 2.0 (the\n// \"License\"); you may not use this file except in compliance\n// with the License.  You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing,\n// software distributed under the License is distributed on an\n// \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n// KIND, either express or implied.  See the License for the\n// specific language governing permissions and limitations\n// under the License.\n\nimport { Field, Schema } from './schema.js';\nimport * as dtypes from './type.js';\nimport { Data, DataProps } from './data.js';\nimport { BuilderType, JavaScriptDataType } from './interfaces.js';\nimport { Vector, makeVector } from './vector.js';\nimport { Builder, BuilderOptions } from './builder.js';\nimport { instance as getBuilderConstructor } from './visitor/builderctor.js';\nimport { ArrayDataType, BigIntArray, JavaScriptArrayDataType, TypedArray, TypedArrayDataType } from './interfaces.js';\nimport { Table } from './table.js';\nimport { RecordBatch } from './recordbatch.js';\nimport { compareTypes } from './visitor/typecomparator.js';\n\nexport function makeBuilder<T extends dtypes.DataType = any, TNull = any>(options: BuilderOptions<T, TNull>): BuilderType<T, TNull> {\n\n    const type = options.type;\n    const builder = new (getBuilderConstructor.getVisitFn<T>(type)())(options) as Builder<T, TNull>;\n\n    if (type.children && type.children.length > 0) {\n\n        const children = options['children'] || [] as BuilderOptions[];\n        const defaultOptions = { 'nullValues': options['nullValues'] };\n        const getChildOptions = Array.isArray(children)\n            ? ((_: Field, i: number) => children[i] || defaultOptions)\n            : (({ name }: Field) => children[name] || defaultOptions);\n\n        for (const [index, field] of type.children.entries()) {\n            const { type } = field;\n            const opts = getChildOptions(field, index);\n            builder.children.push(makeBuilder({ ...opts, type }));\n        }\n    }\n\n    return builder as BuilderType<T, TNull>;\n}\n\n/**\n * Creates a Vector from a JavaScript array via a {@link Builder}.\n * Use {@link makeVector} if you only want to create a vector from a typed array.\n *\n * @example\n * ```ts\n * const vf64 = vectorFromArray([1, 2, 3]);\n * const vi8 = vectorFromArray([1, 2, 3], new Int8);\n * const vdict = vectorFromArray(['foo', 'bar']);\n * const vstruct = vectorFromArray([{a: 'foo', b: 42}, {a: 'bar', b: 12}]);\n * ```\n */\nexport function vectorFromArray(values: readonly (null | undefined)[], type?: dtypes.Null): Vector<dtypes.Null>;\nexport function vectorFromArray(values: readonly (null | undefined | boolean)[], type?: dtypes.Bool): Vector<dtypes.Bool>;\nexport function vectorFromArray<T extends dtypes.Utf8 | dtypes.Dictionary<dtypes.Utf8> = dtypes.Dictionary<dtypes.Utf8, dtypes.Int32>>(values: readonly (null | undefined | string)[], type?: T): Vector<T>;\nexport function vectorFromArray<T extends dtypes.Date_>(values: readonly (null | undefined | Date)[], type?: T): Vector<T>;\nexport function vectorFromArray<T extends dtypes.Int>(values: readonly (null | undefined | number)[], type: T): Vector<T>;\nexport function vectorFromArray<T extends dtypes.Int64 | dtypes.Uint64 = dtypes.Int64>(values: readonly (null | undefined | bigint)[], type?: T): Vector<T>;\nexport function vectorFromArray<T extends dtypes.Float = dtypes.Float64>(values: readonly (null | undefined | number)[], type?: T): Vector<T>;\nexport function vectorFromArray<T extends dtypes.DataType>(values: readonly (unknown)[], type: T): Vector<T>;\nexport function vectorFromArray<T extends readonly unknown[]>(values: T): Vector<JavaScriptArrayDataType<T>>;\n/** Creates a Vector from a typed array via {@link makeVector}. */\nexport function vectorFromArray<T extends TypedArray | BigIntArray>(data: T): Vector<TypedArrayDataType<T>>;\n\nexport function vectorFromArray<T extends dtypes.DataType>(data: Data<T>): Vector<T>;\nexport function vectorFromArray<T extends dtypes.DataType>(data: Vector<T>): Vector<T>;\nexport function vectorFromArray<T extends dtypes.DataType>(data: DataProps<T>): Vector<T>;\nexport function vectorFromArray<T extends TypedArray | BigIntArray | readonly unknown[]>(data: T): Vector<ArrayDataType<T>>;\n\nexport function vectorFromArray(init: any, type?: dtypes.DataType) {\n    if (init instanceof Data || init instanceof Vector || init.type instanceof dtypes.DataType || ArrayBuffer.isView(init)) {\n        return makeVector(init as any);\n    }\n    const options: IterableBuilderOptions = { type: type ?? inferType(init), nullValues: [null] };\n    const chunks = [...builderThroughIterable(options)(init)];\n    const vector = chunks.length === 1 ? chunks[0] : chunks.reduce((a, b) => a.concat(b));\n    if (dtypes.DataType.isDictionary(vector.type)) {\n        return vector.memoize();\n    }\n    return vector;\n}\n\n/**\n * Creates a {@link Table} from an array of objects.\n *\n * @param array A table of objects.\n */\nexport function tableFromJSON<T extends Record<string, unknown>>(array: T[]): Table<{ [P in keyof T]: JavaScriptDataType<T[P]> }> {\n    const vector = vectorFromArray(array) as Vector<dtypes.Struct<any>>;\n    const batch = new RecordBatch(new Schema(vector.type.children), vector.data[0]);\n    return new Table(batch);\n}\n\n/** @ignore */\nfunction inferType<T extends readonly unknown[]>(values: T): JavaScriptArrayDataType<T>;\nfunction inferType(value: readonly unknown[]): dtypes.DataType {\n    if (value.length === 0) { return new dtypes.Null; }\n    let nullsCount = 0;\n    let arraysCount = 0;\n    let objectsCount = 0;\n    let numbersCount = 0;\n    let stringsCount = 0;\n    let bigintsCount = 0;\n    let booleansCount = 0;\n    let datesCount = 0;\n\n    for (const val of value) {\n        if (val == null) { ++nullsCount; continue; }\n        switch (typeof val) {\n            case 'bigint': ++bigintsCount; continue;\n            case 'boolean': ++booleansCount; continue;\n            case 'number': ++numbersCount; continue;\n            case 'string': ++stringsCount; continue;\n            case 'object':\n                if (Array.isArray(val)) {\n                    ++arraysCount;\n                } else if (Object.prototype.toString.call(val) === '[object Date]') {\n                    ++datesCount;\n                } else {\n                    ++objectsCount;\n                }\n                continue;\n        }\n        throw new TypeError('Unable to infer Vector type from input values, explicit type declaration expected');\n    }\n\n    if (numbersCount + nullsCount === value.length) {\n        return new dtypes.Float64;\n    } else if (stringsCount + nullsCount === value.length) {\n        return new dtypes.Dictionary(new dtypes.Utf8, new dtypes.Int32);\n    } else if (bigintsCount + nullsCount === value.length) {\n        return new dtypes.Int64;\n    } else if (booleansCount + nullsCount === value.length) {\n        return new dtypes.Bool;\n    } else if (datesCount + nullsCount === value.length) {\n        return new dtypes.DateMillisecond;\n    } else if (arraysCount + nullsCount === value.length) {\n        const array = value as Array<unknown>[];\n        const childType = inferType(array[array.findIndex((ary) => ary != null)]);\n        if (array.every((ary) => ary == null || compareTypes(childType, inferType(ary)))) {\n            return new dtypes.List(new Field('', childType, true));\n        }\n    } else if (objectsCount + nullsCount === value.length) {\n        const fields = new Map<string, Field>();\n        for (const row of value as Record<string, unknown>[]) {\n            for (const key of Object.keys(row)) {\n                if (!fields.has(key) && row[key] != null) {\n                    // use the type inferred for the first instance of a found key\n                    fields.set(key, new Field(key, inferType([row[key]]), true));\n                }\n            }\n        }\n        return new dtypes.Struct([...fields.values()]);\n    }\n\n    throw new TypeError('Unable to infer Vector type from input values, explicit type declaration expected');\n}\n\n/**\n * A set of options to create an Iterable or AsyncIterable `Builder` transform function.\n * @see {@link builderThroughIterable}\n * @see {@link builderThroughAsyncIterable}\n */\nexport interface IterableBuilderOptions<T extends dtypes.DataType = any, TNull = any> extends BuilderOptions<T, TNull> {\n    highWaterMark?: number;\n    queueingStrategy?: 'bytes' | 'count';\n    dictionaryHashFunction?: (value: any) => string | number;\n    valueToChildTypeId?: (builder: Builder<T, TNull>, value: any, offset: number) => number;\n}\n\n/** @ignore */\ntype ThroughIterable<T extends dtypes.DataType = any, TNull = any> = (source: Iterable<T['TValue'] | TNull>) => IterableIterator<Vector<T>>;\n\n/**\n * Transform a synchronous `Iterable` of arbitrary JavaScript values into a\n * sequence of Arrow Vector<T> following the chunking semantics defined in\n * the supplied `options` argument.\n *\n * This function returns a function that accepts an `Iterable` of values to\n * transform. When called, this function returns an Iterator of `Vector<T>`.\n *\n * The resulting `Iterator<Vector<T>>` yields Vectors based on the\n * `queueingStrategy` and `highWaterMark` specified in the `options` argument.\n *\n * * If `queueingStrategy` is `\"count\"` (or omitted), The `Iterator<Vector<T>>`\n *   will flush the underlying `Builder` (and yield a new `Vector<T>`) once the\n *   Builder's `length` reaches or exceeds the supplied `highWaterMark`.\n * * If `queueingStrategy` is `\"bytes\"`, the `Iterator<Vector<T>>` will flush\n *   the underlying `Builder` (and yield a new `Vector<T>`) once its `byteLength`\n *   reaches or exceeds the supplied `highWaterMark`.\n *\n * @param {IterableBuilderOptions<T, TNull>} options An object of properties which determine the `Builder` to create and the chunking semantics to use.\n * @returns A function which accepts a JavaScript `Iterable` of values to\n *          write, and returns an `Iterator` that yields Vectors according\n *          to the chunking semantics defined in the `options` argument.\n * @nocollapse\n */\nexport function builderThroughIterable<T extends dtypes.DataType = any, TNull = any>(options: IterableBuilderOptions<T, TNull>) {\n    const { ['queueingStrategy']: queueingStrategy = 'count' } = options;\n    const { ['highWaterMark']: highWaterMark = queueingStrategy !== 'bytes' ? Number.POSITIVE_INFINITY : 2 ** 14 } = options;\n    const sizeProperty: 'length' | 'byteLength' = queueingStrategy !== 'bytes' ? 'length' : 'byteLength';\n    return function* (source: Iterable<T['TValue'] | TNull>) {\n        let numChunks = 0;\n        const builder = makeBuilder(options);\n        for (const value of source) {\n            if (builder.append(value)[sizeProperty] >= highWaterMark) {\n                ++numChunks && (yield builder.toVector());\n            }\n        }\n        if (builder.finish().length > 0 || numChunks === 0) {\n            yield builder.toVector();\n        }\n    } as ThroughIterable<T, TNull>;\n}\n\n/** @ignore */\ntype ThroughAsyncIterable<T extends dtypes.DataType = any, TNull = any> = (source: Iterable<T['TValue'] | TNull> | AsyncIterable<T['TValue'] | TNull>) => AsyncIterableIterator<Vector<T>>;\n\n/**\n * Transform an `AsyncIterable` of arbitrary JavaScript values into a\n * sequence of Arrow Vector<T> following the chunking semantics defined in\n * the supplied `options` argument.\n *\n * This function returns a function that accepts an `AsyncIterable` of values to\n * transform. When called, this function returns an AsyncIterator of `Vector<T>`.\n *\n * The resulting `AsyncIterator<Vector<T>>` yields Vectors based on the\n * `queueingStrategy` and `highWaterMark` specified in the `options` argument.\n *\n * * If `queueingStrategy` is `\"count\"` (or omitted), The `AsyncIterator<Vector<T>>`\n *   will flush the underlying `Builder` (and yield a new `Vector<T>`) once the\n *   Builder's `length` reaches or exceeds the supplied `highWaterMark`.\n * * If `queueingStrategy` is `\"bytes\"`, the `AsyncIterator<Vector<T>>` will flush\n *   the underlying `Builder` (and yield a new `Vector<T>`) once its `byteLength`\n *   reaches or exceeds the supplied `highWaterMark`.\n *\n * @param {IterableBuilderOptions<T, TNull>} options An object of properties which determine the `Builder` to create and the chunking semantics to use.\n * @returns A function which accepts a JavaScript `AsyncIterable` of values\n *          to write, and returns an `AsyncIterator` that yields Vectors\n *          according to the chunking semantics defined in the `options`\n *          argument.\n * @nocollapse\n */\nexport function builderThroughAsyncIterable<T extends dtypes.DataType = any, TNull = any>(options: IterableBuilderOptions<T, TNull>) {\n    const { ['queueingStrategy']: queueingStrategy = 'count' } = options;\n    const { ['highWaterMark']: highWaterMark = queueingStrategy !== 'bytes' ? Number.POSITIVE_INFINITY : 2 ** 14 } = options;\n    const sizeProperty: 'length' | 'byteLength' = queueingStrategy !== 'bytes' ? 'length' : 'byteLength';\n    return async function* (source: Iterable<T['TValue'] | TNull> | AsyncIterable<T['TValue'] | TNull>) {\n        let numChunks = 0;\n        const builder = makeBuilder(options);\n        for await (const value of source) {\n            if (builder.append(value)[sizeProperty] >= highWaterMark) {\n                ++numChunks && (yield builder.toVector());\n            }\n        }\n        if (builder.finish().length > 0 || numChunks === 0) {\n            yield builder.toVector();\n        }\n    } as ThroughAsyncIterable<T, TNull>;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}